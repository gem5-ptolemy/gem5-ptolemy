
/*
 * DO NOT EDIT THIS FILE!!!
 *
 * It was automatically generated from the ISA description in alpha/isa/main.isa
 */

#include "decoder.hh"


#include <cmath>

#include "arch/alpha/decoder.hh"
#include "arch/alpha/registers.hh"
#include "arch/alpha/regredir.hh"
#include "base/loader/symtab.hh"
#include "base/cprintf.hh"
#include "base/fenv.hh"
#include "config/ss_compatible_fp.hh"
#include "cpu/thread_context.hh"  // for Jump::branchTarget()
#include "mem/packet.hh"
#include "sim/full_system.hh"

using namespace AlphaISA;


namespace AlphaISAInst {


    void
    AlphaStaticInst::printReg(std::ostream &os, int reg) const
    {
        if (reg < FP_Reg_Base) {
            ccprintf(os, "r%d", reg);
        }
        else {
            ccprintf(os, "f%d", reg - FP_Reg_Base);
        }
    }

    std::string
    AlphaStaticInst::generateDisassembly(Addr pc,
                                         const SymbolTable *symtab) const
    {
        std::stringstream ss;

        ccprintf(ss, "%-10s ", mnemonic);

        // just print the first two source regs... if there's
        // a third one, it's a read-modify-write dest (Rc),
        // e.g. for CMOVxx
        if (_numSrcRegs > 0) {
            printReg(ss, _srcRegIdx[0]);
        }
        if (_numSrcRegs > 1) {
            ss << ",";
            printReg(ss, _srcRegIdx[1]);
        }

        // just print the first dest... if there's a second one,
        // it's generally implicit
        if (_numDestRegs > 0) {
            if (_numSrcRegs > 0)
                ss << ",";
            printReg(ss, _destRegIdx[0]);
        }

        return ss.str();
    }

    std::string Nop::generateDisassembly(Addr pc,
                                         const SymbolTable *symtab) const
    {
#ifdef SS_COMPATIBLE_DISASSEMBLY
        return originalDisassembly;
#else
        return csprintf("%-10s (%s)", "nop", originalDisassembly);
#endif
    }

    std::string
    IntegerImm::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        std::stringstream ss;

        ccprintf(ss, "%-10s ", mnemonic);

        // just print the first source reg... if there's
        // a second one, it's a read-modify-write dest (Rc),
        // e.g. for CMOVxx
        if (_numSrcRegs > 0) {
            printReg(ss, _srcRegIdx[0]);
            ss << ",";
        }

        ss << (int)imm;

        if (_numDestRegs > 0) {
            ss << ",";
            printReg(ss, _destRegIdx[0]);
        }

        return ss.str();
    }

    int
    AlphaFP::getC99RoundingMode(uint64_t fpcr_val) const
    {
        if (roundingMode == Dynamic) {
            return alphaToC99RoundingMode[bits(fpcr_val, 59, 58)];
        }
        else {
            return alphaToC99RoundingMode[roundingMode];
        }
    }

    std::string
    AlphaFP::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        std::string mnem_str(mnemonic);

#ifndef SS_COMPATIBLE_DISASSEMBLY
        std::string suffix("");
        suffix += ((_destRegIdx[0] >= FP_Reg_Base)
                   ? fpTrappingModeSuffix[trappingMode]
                   : intTrappingModeSuffix[trappingMode]);
        suffix += roundingModeSuffix[roundingMode];

        if (suffix != "") {
            mnem_str = csprintf("%s/%s", mnemonic, suffix);
        }
#endif

        std::stringstream ss;
        ccprintf(ss, "%-10s ", mnem_str.c_str());

        // just print the first two source regs... if there's
        // a third one, it's a read-modify-write dest (Rc),
        // e.g. for CMOVxx
        if (_numSrcRegs > 0) {
            printReg(ss, _srcRegIdx[0]);
        }
        if (_numSrcRegs > 1) {
            ss << ",";
            printReg(ss, _srcRegIdx[1]);
        }

        // just print the first dest... if there's a second one,
        // it's generally implicit
        if (_numDestRegs > 0) {
            if (_numSrcRegs > 0)
                ss << ",";
            printReg(ss, _destRegIdx[0]);
        }

        return ss.str();
    }

    const int AlphaFP::alphaToC99RoundingMode[] = {
        M5_FE_TOWARDZERO,       // Chopped
        M5_FE_DOWNWARD, // Minus_Infinity
        M5_FE_TONEAREST,        // Normal
        M5_FE_UPWARD    // Dynamic in inst, Plus_Infinity in FPCR
    };

    const char *AlphaFP::roundingModeSuffix[] = { "c", "m", "", "d" };
    // mark invalid trapping modes, but don't fail on them, because
    // you could decode anything on a misspeculated path
    const char *AlphaFP::fpTrappingModeSuffix[] =
        { "", "u", "INVTM2", "INVTM3", "INVTM4", "su", "INVTM6", "sui" };
    const char *AlphaFP::intTrappingModeSuffix[] =
        { "", "v", "INVTM2", "INVTM3", "INVTM4", "sv", "INVTM6", "svi" };

    std::string
    Memory::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s %c%d,%d(r%d)", mnemonic,
                        flags[IsFloating] ? 'f' : 'r', RA, MEMDISP, RB);
    }

    std::string
    MemoryNoDisp::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s (r%d)", mnemonic, RB);
    }

    AlphaISA::PCState
    Branch::branchTarget(const AlphaISA::PCState &branchPC) const
    {
        return branchPC.pc() + 4 + disp;
    }

    AlphaISA::PCState
    Jump::branchTarget(ThreadContext *tc) const
    {
        PCState pc = tc->pcState();
        uint64_t Rb = tc->readIntReg(_srcRegIdx[0]);
        pc.set((Rb & ~3) | (pc.pc() & 1));
        return pc;
    }

    const std::string &
    PCDependentDisassembly::disassemble(Addr pc,
                                        const SymbolTable *symtab) const
    {
        if (!cachedDisassembly ||
            pc != cachedPC || symtab != cachedSymtab)
        {
            if (cachedDisassembly)
                delete cachedDisassembly;

            cachedDisassembly =
                new std::string(generateDisassembly(pc, symtab));
            cachedPC = pc;
            cachedSymtab = symtab;
        }

        return *cachedDisassembly;
    }

    std::string
    Branch::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        std::stringstream ss;

        ccprintf(ss, "%-10s ", mnemonic);

        // There's only one register arg (RA), but it could be
        // either a source (the condition for conditional
        // branches) or a destination (the link reg for
        // unconditional branches)
        if (_numSrcRegs > 0) {
            printReg(ss, _srcRegIdx[0]);
            ss << ",";
        }
        else if (_numDestRegs > 0) {
            printReg(ss, _destRegIdx[0]);
            ss << ",";
        }

#ifdef SS_COMPATIBLE_DISASSEMBLY
        if (_numSrcRegs == 0 && _numDestRegs == 0) {
            printReg(ss, 31);
            ss << ",";
        }
#endif

        Addr target = pc + 4 + disp;

        std::string str;
        if (symtab && symtab->findSymbol(target, str))
            ss << str;
        else
            ccprintf(ss, "0x%x", target);

        return ss.str();
    }

    std::string
    Jump::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        std::stringstream ss;

        ccprintf(ss, "%-10s ", mnemonic);

#ifdef SS_COMPATIBLE_DISASSEMBLY
        if (_numDestRegs == 0) {
            printReg(ss, 31);
            ss << ",";
        }
#endif

        if (_numDestRegs > 0) {
            printReg(ss, _destRegIdx[0]);
            ss << ",";
        }

        ccprintf(ss, "(r%d)", RB);

        return ss.str();
    }

    std::string
    EmulatedCallPal::generateDisassembly(Addr pc,
                                         const SymbolTable *symtab) const
    {
#ifdef SS_COMPATIBLE_DISASSEMBLY
        return csprintf("%s %s", "call_pal", mnemonic);
#else
        return csprintf("%-10s %s", "call_pal", mnemonic);
#endif
    }

    inline
    CallPalBase::CallPalBase(const char *mnem, ExtMachInst _machInst,
                             OpClass __opClass)
        : AlphaStaticInst(mnem, _machInst, __opClass),
        palFunc(PALFUNC)
    {
        // From the 21164 HRM (paraphrased):
        // Bit 7 of the function code (mask 0x80) indicates
        // whether the call is privileged (bit 7 == 0) or
        // unprivileged (bit 7 == 1).  The privileged call table
        // starts at 0x2000, the unprivielged call table starts at
        // 0x3000.  Bits 5-0 (mask 0x3f) are used to calculate the
        // offset.
        const int palPrivMask = 0x80;
        const int palOffsetMask = 0x3f;

        // Pal call is invalid unless all other bits are 0
        palValid = ((machInst & ~(palPrivMask | palOffsetMask)) == 0);
        palPriv = ((machInst & palPrivMask) == 0);
        int shortPalFunc = (machInst & palOffsetMask);
        // Add 1 to base to set pal-mode bit
        palOffset = (palPriv ? 0x2001 : 0x3001) + (shortPalFunc << 6);
    }

    std::string
    CallPalBase::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s %#x", "call_pal", palFunc);
    }

    inline
    HwLoadStore::HwLoadStore(const char *mnem, ExtMachInst _machInst,
                             OpClass __opClass)
        : Memory(mnem, _machInst, __opClass), disp(HW_LDST_DISP)
    {
        memAccessFlags.clear();
        if (HW_LDST_PHYS) memAccessFlags.set(Request::PHYSICAL);
        if (HW_LDST_ALT)  memAccessFlags.set(Request::ALTMODE);
        if (HW_LDST_VPTE) memAccessFlags.set(Request::VPTE);
        if (HW_LDST_LOCK) memAccessFlags.set(Request::LLSC);
    }

    std::string
    HwLoadStore::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
#ifdef SS_COMPATIBLE_DISASSEMBLY
        return csprintf("%-10s r%d,%d(r%d)", mnemonic, RA, disp, RB);
#else
        // HW_LDST_LOCK and HW_LDST_COND are the same bit.
        const char *lock_str =
            (HW_LDST_LOCK) ? (flags[IsLoad] ? ",LOCK" : ",COND") : "";

        return csprintf("%-10s r%d,%d(r%d)%s%s%s%s%s",
                        mnemonic, RA, disp, RB,
                        HW_LDST_PHYS ? ",PHYS" : "",
                        HW_LDST_ALT ? ",ALT" : "",
                        HW_LDST_QUAD ? ",QUAD" : "",
                        HW_LDST_VPTE ? ",VPTE" : "",
                        lock_str);
#endif
    }

    std::string
    HwMoveIPR::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        if (_numSrcRegs > 0) {
            // must be mtpr
            return csprintf("%-10s r%d,IPR(%#x)",
                            mnemonic, RA, ipr_index);
        }
        else {
            // must be mfpr
            return csprintf("%-10s IPR(%#x),r%d",
                            mnemonic, ipr_index, RA);
        }
    }

    std::string
    OpcdecFault::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s (inst 0x%x, opcode 0x%x)",
                        " OPCDEC fault", machInst, OPCODE);
    }

    std::string
    FailUnimplemented::generateDisassembly(Addr pc,
                                           const SymbolTable *symtab) const
    {
        return csprintf("%-10s (unimplemented)", mnemonic);
    }

    std::string
    WarnUnimplemented::generateDisassembly(Addr pc,
                                           const SymbolTable *symtab) const
    {
#ifdef SS_COMPATIBLE_DISASSEMBLY
        return csprintf("%-10s", mnemonic);
#else
        return csprintf("%-10s (unimplemented)", mnemonic);
#endif
    }

    std::string
    Unknown::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s (inst 0x%x, opcode 0x%x)",
                        "unknown", machInst, OPCODE);
    }

// LoadAddress::lda([' Ra = Rb + disp; '],{})

    inline Lda::Lda(ExtMachInst machInst)
         : MemoryDisp32("lda", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;;
    }

// LoadAddress::ldah([' Ra = Rb + (disp << 16); '],{})

    inline Ldah::Ldah(ExtMachInst machInst)
         : MemoryDisp32("ldah", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;;
    }

// LoadOrNop::ldbu([' Ra_uq = Mem_ub; '],{})

    inline Ldbu::Ldbu(ExtMachInst machInst)
         : MemoryDisp32("ldbu", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

// LoadOrNop::ldwu([' Ra_uq = Mem_uw; '],{})

    inline Ldwu::Ldwu(ExtMachInst machInst)
         : MemoryDisp32("ldwu", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

// LoadOrNop::ldq_u([' Ra = Mem_uq; '],{'ea_code': ' EA = (Rb + disp) & ~7; '})

    inline Ldq_u::Ldq_u(ExtMachInst machInst)
         : MemoryDisp32("ldq_u", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

// LoadOrNop::ldt([' Fa = Mem_df; '],{})

    inline Ldt::Ldt(ExtMachInst machInst)
         : MemoryDisp32("ldt", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = FA + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

// LoadOrNop::ldl_l([' Ra_sl = Mem_sl; '],{'mem_flags': 'LLSC'})

    inline Ldl_l::Ldl_l(ExtMachInst machInst)
         : MemoryDisp32("ldl_l", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	memAccessFlags = Request::LLSC;;
    }

// LoadOrNop::ldq_l([' Ra_uq = Mem_uq; '],{'mem_flags': 'LLSC'})

    inline Ldq_l::Ldq_l(ExtMachInst machInst)
         : MemoryDisp32("ldq_l", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	memAccessFlags = Request::LLSC;;
    }

// LoadOrPrefetch::ldl([' Ra_sl = Mem_sl; '],{})

    inline Ldl::Ldl(ExtMachInst machInst)
         : MemoryDisp32("ldl", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    inline LdlPrefetch::LdlPrefetch(ExtMachInst machInst)
         : MemoryDisp32("ldl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	memAccessFlags = Request::PREFETCH;;
    }

// LoadOrPrefetch::ldq([' Ra_uq = Mem_uq; '],{'pf_flags': 'EVICT_NEXT'})

    inline Ldq::Ldq(ExtMachInst machInst)
         : MemoryDisp32("ldq", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    inline LdqPrefetch::LdqPrefetch(ExtMachInst machInst)
         : MemoryDisp32("ldq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	memAccessFlags = Request::EVICT_NEXT|Request::PREFETCH;;
    }

// LoadOrPrefetch::lds([' Fa_uq = s_to_t(Mem_ul); '],{'pf_flags': 'PF_EXCLUSIVE', 'inst_flags': 'IsFloating'})

    inline Lds::Lds(ExtMachInst machInst)
         : MemoryDisp32("lds", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = FA + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    inline LdsPrefetch::LdsPrefetch(ExtMachInst machInst)
         : MemoryDisp32("lds", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	memAccessFlags = Request::PF_EXCLUSIVE|Request::PREFETCH;;
    }

// Store::stb([' Mem_ub = Ra<7:0>; '],{})

    inline Stb::Stb(ExtMachInst machInst)
         : MemoryDisp32("stb", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::stw([' Mem_uw = Ra<15:0>; '],{})

    inline Stw::Stw(ExtMachInst machInst)
         : MemoryDisp32("stw", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::stl([' Mem_ul = Ra<31:0>; '],{})

    inline Stl::Stl(ExtMachInst machInst)
         : MemoryDisp32("stl", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::stq([' Mem_uq = Ra_uq; '],{})

    inline Stq::Stq(ExtMachInst machInst)
         : MemoryDisp32("stq", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::stq_u([' Mem_uq = Ra_uq; ', ' EA = (Rb + disp) & ~7; '],{})

    inline Stq_u::Stq_u(ExtMachInst machInst)
         : MemoryDisp32("stq_u", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::sts([' Mem_ul = t_to_s(Fa_uq); '],{})

    inline Sts::Sts(ExtMachInst machInst)
         : MemoryDisp32("sts", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// Store::stt([' Mem_df = Fa; '],{})

    inline Stt::Stt(ExtMachInst machInst)
         : MemoryDisp32("stt", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
    }

// StoreCond::stl_c([' Mem_ul = Ra<31:0>; ', '\n                        uint64_t tmp = write_result;\n                        // see stq_c\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            xc->setStCondFailures(0);\n                        }\n                    '],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    inline Stl_c::Stl_c(ExtMachInst machInst)
         : MemoryDisp32("stl_c", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	memAccessFlags = Request::LLSC;;
    }

// StoreCond::stq_c([' Mem_uq = Ra; ', "\n                        uint64_t tmp = write_result;\n                        // If the write operation returns 0 or 1, then\n                        // this was a conventional store conditional,\n                        // and the value indicates the success/failure\n                        // of the operation.  If another value is\n                        // returned, then this was a Turbolaser\n                        // mailbox access, and we don't update the\n                        // result register at all.\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            // clear failure counter... this is\n                            // non-architectural and for debugging\n                            // only.\n                            xc->setStCondFailures(0);\n                        }\n                    "],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    inline Stq_c::Stq_c(ExtMachInst machInst)
         : MemoryDisp32("stq_c", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	memAccessFlags = Request::LLSC;;
    }

// IntegerOperate::addl([' Rc_sl = Ra_sl + Rb_or_imm_sl; '],{})

    inline Addl::Addl(ExtMachInst machInst)
         : AlphaStaticInst("addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AddlImm::AddlImm(ExtMachInst machInst)
         : IntegerImm("addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::addlv(['\n                int32_t tmp  = Ra_sl + Rb_or_imm_sl;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra_sl<31:> == Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    inline Addlv::Addlv(ExtMachInst machInst)
         : AlphaStaticInst("addlv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AddlvImm::AddlvImm(ExtMachInst machInst)
         : IntegerImm("addlv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s4addl([' Rc_sl = (Ra_sl << 2) + Rb_or_imm_sl; '],{})

    inline S4addl::S4addl(ExtMachInst machInst)
         : AlphaStaticInst("s4addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S4addlImm::S4addlImm(ExtMachInst machInst)
         : IntegerImm("s4addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s8addl([' Rc_sl = (Ra_sl << 3) + Rb_or_imm_sl; '],{})

    inline S8addl::S8addl(ExtMachInst machInst)
         : AlphaStaticInst("s8addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S8addlImm::S8addlImm(ExtMachInst machInst)
         : IntegerImm("s8addl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::addq([' Rc = Ra + Rb_or_imm; '],{})

    inline Addq::Addq(ExtMachInst machInst)
         : AlphaStaticInst("addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AddqImm::AddqImm(ExtMachInst machInst)
         : IntegerImm("addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::addqv(['\n                uint64_t tmp = Ra + Rb_or_imm;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra<63:> == Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    inline Addqv::Addqv(ExtMachInst machInst)
         : AlphaStaticInst("addqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AddqvImm::AddqvImm(ExtMachInst machInst)
         : IntegerImm("addqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s4addq([' Rc = (Ra << 2) + Rb_or_imm; '],{})

    inline S4addq::S4addq(ExtMachInst machInst)
         : AlphaStaticInst("s4addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S4addqImm::S4addqImm(ExtMachInst machInst)
         : IntegerImm("s4addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s8addq([' Rc = (Ra << 3) + Rb_or_imm; '],{})

    inline S8addq::S8addq(ExtMachInst machInst)
         : AlphaStaticInst("s8addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S8addqImm::S8addqImm(ExtMachInst machInst)
         : IntegerImm("s8addq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::subl([' Rc_sl = Ra_sl - Rb_or_imm_sl; '],{})

    inline Subl::Subl(ExtMachInst machInst)
         : AlphaStaticInst("subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SublImm::SublImm(ExtMachInst machInst)
         : IntegerImm("subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::sublv(['\n                int32_t tmp  = Ra_sl - Rb_or_imm_sl;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra_sl<31:> != Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    inline Sublv::Sublv(ExtMachInst machInst)
         : AlphaStaticInst("sublv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SublvImm::SublvImm(ExtMachInst machInst)
         : IntegerImm("sublv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s4subl([' Rc_sl = (Ra_sl << 2) - Rb_or_imm_sl; '],{})

    inline S4subl::S4subl(ExtMachInst machInst)
         : AlphaStaticInst("s4subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S4sublImm::S4sublImm(ExtMachInst machInst)
         : IntegerImm("s4subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s8subl([' Rc_sl = (Ra_sl << 3) - Rb_or_imm_sl; '],{})

    inline S8subl::S8subl(ExtMachInst machInst)
         : AlphaStaticInst("s8subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S8sublImm::S8sublImm(ExtMachInst machInst)
         : IntegerImm("s8subl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::subq([' Rc = Ra - Rb_or_imm; '],{})

    inline Subq::Subq(ExtMachInst machInst)
         : AlphaStaticInst("subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SubqImm::SubqImm(ExtMachInst machInst)
         : IntegerImm("subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::subqv(['\n                uint64_t tmp  = Ra - Rb_or_imm;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra<63:> != Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    inline Subqv::Subqv(ExtMachInst machInst)
         : AlphaStaticInst("subqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SubqvImm::SubqvImm(ExtMachInst machInst)
         : IntegerImm("subqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s4subq([' Rc = (Ra << 2) - Rb_or_imm; '],{})

    inline S4subq::S4subq(ExtMachInst machInst)
         : AlphaStaticInst("s4subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S4subqImm::S4subqImm(ExtMachInst machInst)
         : IntegerImm("s4subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::s8subq([' Rc = (Ra << 3) - Rb_or_imm; '],{})

    inline S8subq::S8subq(ExtMachInst machInst)
         : AlphaStaticInst("s8subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline S8subqImm::S8subqImm(ExtMachInst machInst)
         : IntegerImm("s8subq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmpeq([' Rc = (Ra == Rb_or_imm); '],{})

    inline Cmpeq::Cmpeq(ExtMachInst machInst)
         : AlphaStaticInst("cmpeq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpeqImm::CmpeqImm(ExtMachInst machInst)
         : IntegerImm("cmpeq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmple([' Rc = (Ra_sq <= Rb_or_imm_sq); '],{})

    inline Cmple::Cmple(ExtMachInst machInst)
         : AlphaStaticInst("cmple", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpleImm::CmpleImm(ExtMachInst machInst)
         : IntegerImm("cmple", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmplt([' Rc = (Ra_sq <  Rb_or_imm_sq); '],{})

    inline Cmplt::Cmplt(ExtMachInst machInst)
         : AlphaStaticInst("cmplt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpltImm::CmpltImm(ExtMachInst machInst)
         : IntegerImm("cmplt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmpule([' Rc = (Ra_uq <= Rb_or_imm_uq); '],{})

    inline Cmpule::Cmpule(ExtMachInst machInst)
         : AlphaStaticInst("cmpule", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpuleImm::CmpuleImm(ExtMachInst machInst)
         : IntegerImm("cmpule", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmpult([' Rc = (Ra_uq <  Rb_or_imm_uq); '],{})

    inline Cmpult::Cmpult(ExtMachInst machInst)
         : AlphaStaticInst("cmpult", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpultImm::CmpultImm(ExtMachInst machInst)
         : IntegerImm("cmpult", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmpbge(['\n                int hi = 7;\n                int lo = 0;\n                uint64_t tmp = 0;\n                for (int i = 0; i < 8; ++i) {\n                    tmp |= (Ra_uq<hi:lo> >= Rb_or_imm_uq<hi:lo>) << i;\n                    hi += 8;\n                    lo += 8;\n                }\n                Rc = tmp;\n            '],{})

    inline Cmpbge::Cmpbge(ExtMachInst machInst)
         : AlphaStaticInst("cmpbge", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmpbgeImm::CmpbgeImm(ExtMachInst machInst)
         : IntegerImm("cmpbge", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::and([' Rc = Ra & Rb_or_imm; '],{})

    inline And::And(ExtMachInst machInst)
         : AlphaStaticInst("and", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AndImm::AndImm(ExtMachInst machInst)
         : IntegerImm("and", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::bic([' Rc = Ra & ~Rb_or_imm; '],{})

    inline Bic::Bic(ExtMachInst machInst)
         : AlphaStaticInst("bic", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline BicImm::BicImm(ExtMachInst machInst)
         : IntegerImm("bic", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::bis([' Rc = Ra | Rb_or_imm; '],{})

    inline Bis::Bis(ExtMachInst machInst)
         : AlphaStaticInst("bis", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline BisImm::BisImm(ExtMachInst machInst)
         : IntegerImm("bis", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::ornot([' Rc = Ra | ~Rb_or_imm; '],{})

    inline Ornot::Ornot(ExtMachInst machInst)
         : AlphaStaticInst("ornot", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline OrnotImm::OrnotImm(ExtMachInst machInst)
         : IntegerImm("ornot", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::xor([' Rc = Ra ^ Rb_or_imm; '],{})

    inline Xor::Xor(ExtMachInst machInst)
         : AlphaStaticInst("xor", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline XorImm::XorImm(ExtMachInst machInst)
         : IntegerImm("xor", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::eqv([' Rc = Ra ^ ~Rb_or_imm; '],{})

    inline Eqv::Eqv(ExtMachInst machInst)
         : AlphaStaticInst("eqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline EqvImm::EqvImm(ExtMachInst machInst)
         : IntegerImm("eqv", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovlbs([' Rc = ((Ra & 1) == 1) ? Rb_or_imm : Rc; '],{})

    inline Cmovlbs::Cmovlbs(ExtMachInst machInst)
         : AlphaStaticInst("cmovlbs", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovlbsImm::CmovlbsImm(ExtMachInst machInst)
         : IntegerImm("cmovlbs", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovlbc([' Rc = ((Ra & 1) == 0) ? Rb_or_imm : Rc; '],{})

    inline Cmovlbc::Cmovlbc(ExtMachInst machInst)
         : AlphaStaticInst("cmovlbc", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovlbcImm::CmovlbcImm(ExtMachInst machInst)
         : IntegerImm("cmovlbc", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmoveq([' Rc = (Ra == 0) ? Rb_or_imm : Rc; '],{})

    inline Cmoveq::Cmoveq(ExtMachInst machInst)
         : AlphaStaticInst("cmoveq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmoveqImm::CmoveqImm(ExtMachInst machInst)
         : IntegerImm("cmoveq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovne([' Rc = (Ra != 0) ? Rb_or_imm : Rc; '],{})

    inline Cmovne::Cmovne(ExtMachInst machInst)
         : AlphaStaticInst("cmovne", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovneImm::CmovneImm(ExtMachInst machInst)
         : IntegerImm("cmovne", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovlt([' Rc = (Ra_sq <  0) ? Rb_or_imm : Rc; '],{})

    inline Cmovlt::Cmovlt(ExtMachInst machInst)
         : AlphaStaticInst("cmovlt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovltImm::CmovltImm(ExtMachInst machInst)
         : IntegerImm("cmovlt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovge([' Rc = (Ra_sq >= 0) ? Rb_or_imm : Rc; '],{})

    inline Cmovge::Cmovge(ExtMachInst machInst)
         : AlphaStaticInst("cmovge", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovgeImm::CmovgeImm(ExtMachInst machInst)
         : IntegerImm("cmovge", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovle([' Rc = (Ra_sq <= 0) ? Rb_or_imm : Rc; '],{})

    inline Cmovle::Cmovle(ExtMachInst machInst)
         : AlphaStaticInst("cmovle", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovleImm::CmovleImm(ExtMachInst machInst)
         : IntegerImm("cmovle", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cmovgt([' Rc = (Ra_sq >  0) ? Rb_or_imm : Rc; '],{})

    inline Cmovgt::Cmovgt(ExtMachInst machInst)
         : AlphaStaticInst("cmovgt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline CmovgtImm::CmovgtImm(ExtMachInst machInst)
         : IntegerImm("cmovgt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RC] : RC;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::amask([' Rc = Rb_or_imm & ~ULL(0x17); '],{})

    inline Amask::Amask(ExtMachInst machInst)
         : AlphaStaticInst("amask", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline AmaskImm::AmaskImm(ExtMachInst machInst)
         : IntegerImm("amask", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::implver([' Rc = FullSystem ? 1 : 2 '],{})

    inline Implver::Implver(ExtMachInst machInst)
         : AlphaStaticInst("implver", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// WarnUnimpl::eleven25(([], {}))

// Unknown::unknown(([], {}))

// IntegerOperate::sll([' Rc = Ra << Rb_or_imm<5:0>; '],{})

    inline Sll::Sll(ExtMachInst machInst)
         : AlphaStaticInst("sll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SllImm::SllImm(ExtMachInst machInst)
         : IntegerImm("sll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::srl([' Rc = Ra_uq >> Rb_or_imm<5:0>; '],{})

    inline Srl::Srl(ExtMachInst machInst)
         : AlphaStaticInst("srl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SrlImm::SrlImm(ExtMachInst machInst)
         : IntegerImm("srl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::sra([' Rc = Ra_sq >> Rb_or_imm<5:0>; '],{})

    inline Sra::Sra(ExtMachInst machInst)
         : AlphaStaticInst("sra", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SraImm::SraImm(ExtMachInst machInst)
         : IntegerImm("sra", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskbl([' Rc = Ra & ~(mask( 8) << (Rb_or_imm<2:0> * 8)); '],{})

    inline Mskbl::Mskbl(ExtMachInst machInst)
         : AlphaStaticInst("mskbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskblImm::MskblImm(ExtMachInst machInst)
         : IntegerImm("mskbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskwl([' Rc = Ra & ~(mask(16) << (Rb_or_imm<2:0> * 8)); '],{})

    inline Mskwl::Mskwl(ExtMachInst machInst)
         : AlphaStaticInst("mskwl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskwlImm::MskwlImm(ExtMachInst machInst)
         : IntegerImm("mskwl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskll([' Rc = Ra & ~(mask(32) << (Rb_or_imm<2:0> * 8)); '],{})

    inline Mskll::Mskll(ExtMachInst machInst)
         : AlphaStaticInst("mskll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskllImm::MskllImm(ExtMachInst machInst)
         : IntegerImm("mskll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskql([' Rc = Ra & ~(mask(64) << (Rb_or_imm<2:0> * 8)); '],{})

    inline Mskql::Mskql(ExtMachInst machInst)
         : AlphaStaticInst("mskql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskqlImm::MskqlImm(ExtMachInst machInst)
         : IntegerImm("mskql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskwh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;\n            '],{})

    inline Mskwh::Mskwh(ExtMachInst machInst)
         : AlphaStaticInst("mskwh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskwhImm::MskwhImm(ExtMachInst machInst)
         : IntegerImm("mskwh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::msklh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;\n            '],{})

    inline Msklh::Msklh(ExtMachInst machInst)
         : AlphaStaticInst("msklh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MsklhImm::MsklhImm(ExtMachInst machInst)
         : IntegerImm("msklh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mskqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;\n            '],{})

    inline Mskqh::Mskqh(ExtMachInst machInst)
         : AlphaStaticInst("mskqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MskqhImm::MskqhImm(ExtMachInst machInst)
         : IntegerImm("mskqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extbl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))< 7:0>; '],{})

    inline Extbl::Extbl(ExtMachInst machInst)
         : AlphaStaticInst("extbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtblImm::ExtblImm(ExtMachInst machInst)
         : IntegerImm("extbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extwl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<15:0>; '],{})

    inline Extwl::Extwl(ExtMachInst machInst)
         : AlphaStaticInst("extwl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtwlImm::ExtwlImm(ExtMachInst machInst)
         : IntegerImm("extwl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extll([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<31:0>; '],{})

    inline Extll::Extll(ExtMachInst machInst)
         : AlphaStaticInst("extll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtllImm::ExtllImm(ExtMachInst machInst)
         : IntegerImm("extll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extql([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8)); '],{})

    inline Extql::Extql(ExtMachInst machInst)
         : AlphaStaticInst("extql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtqlImm::ExtqlImm(ExtMachInst machInst)
         : IntegerImm("extql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extwh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<15:0>; '],{})

    inline Extwh::Extwh(ExtMachInst machInst)
         : AlphaStaticInst("extwh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtwhImm::ExtwhImm(ExtMachInst machInst)
         : IntegerImm("extwh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extlh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<31:0>; '],{})

    inline Extlh::Extlh(ExtMachInst machInst)
         : AlphaStaticInst("extlh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtlhImm::ExtlhImm(ExtMachInst machInst)
         : IntegerImm("extlh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::extqh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>); '],{})

    inline Extqh::Extqh(ExtMachInst machInst)
         : AlphaStaticInst("extqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ExtqhImm::ExtqhImm(ExtMachInst machInst)
         : IntegerImm("extqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::insbl([' Rc = Ra< 7:0> << (Rb_or_imm<2:0> * 8); '],{})

    inline Insbl::Insbl(ExtMachInst machInst)
         : AlphaStaticInst("insbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InsblImm::InsblImm(ExtMachInst machInst)
         : IntegerImm("insbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::inswl([' Rc = Ra<15:0> << (Rb_or_imm<2:0> * 8); '],{})

    inline Inswl::Inswl(ExtMachInst machInst)
         : AlphaStaticInst("inswl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InswlImm::InswlImm(ExtMachInst machInst)
         : IntegerImm("inswl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::insll([' Rc = Ra<31:0> << (Rb_or_imm<2:0> * 8); '],{})

    inline Insll::Insll(ExtMachInst machInst)
         : AlphaStaticInst("insll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InsllImm::InsllImm(ExtMachInst machInst)
         : IntegerImm("insll", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::insql([' Rc = Ra       << (Rb_or_imm<2:0> * 8); '],{})

    inline Insql::Insql(ExtMachInst machInst)
         : AlphaStaticInst("insql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InsqlImm::InsqlImm(ExtMachInst machInst)
         : IntegerImm("insql", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::inswh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<15:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    inline Inswh::Inswh(ExtMachInst machInst)
         : AlphaStaticInst("inswh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InswhImm::InswhImm(ExtMachInst machInst)
         : IntegerImm("inswh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::inslh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<31:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    inline Inslh::Inslh(ExtMachInst machInst)
         : AlphaStaticInst("inslh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InslhImm::InslhImm(ExtMachInst machInst)
         : IntegerImm("inslh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::insqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq       >> (64 - 8 * bv)) : 0;\n            '],{})

    inline Insqh::Insqh(ExtMachInst machInst)
         : AlphaStaticInst("insqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline InsqhImm::InsqhImm(ExtMachInst machInst)
         : IntegerImm("insqh", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::zap(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    inline Zap::Zap(ExtMachInst machInst)
         : AlphaStaticInst("zap", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ZapImm::ZapImm(ExtMachInst machInst)
         : IntegerImm("zap", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::zapnot(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (!Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    inline Zapnot::Zapnot(ExtMachInst machInst)
         : AlphaStaticInst("zapnot", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline ZapnotImm::ZapnotImm(ExtMachInst machInst)
         : IntegerImm("zapnot", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::mull([' Rc_sl = Ra_sl * Rb_or_imm_sl; ', 'IntMultOp'],{})

    inline Mull::Mull(ExtMachInst machInst)
         : AlphaStaticInst("mull", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MullImm::MullImm(ExtMachInst machInst)
         : IntegerImm("mull", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mulq([' Rc    = Ra    * Rb_or_imm;    ', 'IntMultOp'],{})

    inline Mulq::Mulq(ExtMachInst machInst)
         : AlphaStaticInst("mulq", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MulqImm::MulqImm(ExtMachInst machInst)
         : IntegerImm("mulq", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::umulh(['\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                Rc = hi;\n            ', 'IntMultOp'],{})

    inline Umulh::Umulh(ExtMachInst machInst)
         : AlphaStaticInst("umulh", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline UmulhImm::UmulhImm(ExtMachInst machInst)
         : IntegerImm("umulh", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mullv(['\n                // 32-bit multiply with trap on overflow\n                int64_t Rax = Ra_sl;    // sign extended version of Ra_sl\n                int64_t Rbx = Rb_or_imm_sl;\n                int64_t tmp = Rax * Rbx;\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = tmp<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp<31:0>;\n            ', 'IntMultOp'],{})

    inline Mullv::Mullv(ExtMachInst machInst)
         : AlphaStaticInst("mullv", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MullvImm::MullvImm(ExtMachInst machInst)
         : IntegerImm("mullv", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::mulqv(['\n                // 64-bit multiply with trap on overflow\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                // all the upper 64 bits must match the sign bit of\n                // the lower 64\n                if (!((hi == 0 && lo<63:> == 0) ||\n                      (hi == mask(64) && lo<63:> == 1)))\n                    fault = new IntegerOverflowFault;\n                Rc = lo;\n            ', 'IntMultOp'],{})

    inline Mulqv::Mulqv(ExtMachInst machInst)
         : AlphaStaticInst("mulqv", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline MulqvImm::MulqvImm(ExtMachInst machInst)
         : IntegerImm("mulqv", machInst, IntMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::sextb([' Rc_sb = Rb_or_imm< 7:0>; '],{})

    inline Sextb::Sextb(ExtMachInst machInst)
         : AlphaStaticInst("sextb", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SextbImm::SextbImm(ExtMachInst machInst)
         : IntegerImm("sextb", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::sextw([' Rc_sw = Rb_or_imm<15:0>; '],{})

    inline Sextw::Sextw(ExtMachInst machInst)
         : AlphaStaticInst("sextw", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    inline SextwImm::SextwImm(ExtMachInst machInst)
         : IntegerImm("sextw", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// IntegerOperate::ctpop(['\n                             uint64_t count = 0;\n                             for (int i = 0; Rb<63:i>; ++i) {\n                                 if (Rb<i:i> == 0x1)\n                                     ++count;\n                             }\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    inline Ctpop::Ctpop(ExtMachInst machInst)
         : AlphaStaticInst("ctpop", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::perr(['\n                             uint64_t temp = 0;\n                             int hi = 7;\n                             int lo = 0;\n                             for (int i = 0; i < 8; ++i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp += (ra_ub >= rb_ub) ? \n                                         (ra_ub - rb_ub) : (rb_ub - ra_ub);\n                                 hi += 8;\n                                 lo += 8;\n                             }\n                             Rc = temp;\n                           '],{})

    inline Perr::Perr(ExtMachInst machInst)
         : AlphaStaticInst("perr", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::ctlz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (temp<63:32>) temp >>= 32; else count += 32;\n                             if (temp<31:16>) temp >>= 16; else count += 16;\n                             if (temp<15:8>) temp >>= 8; else count += 8;\n                             if (temp<7:4>) temp >>= 4; else count += 4;\n                             if (temp<3:2>) temp >>= 2; else count += 2;\n                             if (temp<1:1>) temp >>= 1; else count += 1;\n                             if ((temp<0:0>) != 0x1) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    inline Ctlz::Ctlz(ExtMachInst machInst)
         : AlphaStaticInst("ctlz", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::cttz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (!(temp<31:0>)) { temp >>= 32; count += 32; }\n                             if (!(temp<15:0>)) { temp >>= 16; count += 16; }\n                             if (!(temp<7:0>)) { temp >>= 8; count += 8; }\n                             if (!(temp<3:0>)) { temp >>= 4; count += 4; }\n                             if (!(temp<1:0>)) { temp >>= 2; count += 2; }\n                             if (!(temp<0:0> & ULL(0x1))) { \n                                 temp >>= 1; count += 1; \n                             }\n                             if (!(temp<0:0> & ULL(0x1))) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    inline Cttz::Cttz(ExtMachInst machInst)
         : AlphaStaticInst("cttz", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::unpkbw([' \n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<15:8> << 16)\n                                   | (Rb_uq<23:16> << 32)\n                                   | (Rb_uq<31:24> << 48));\n                           ', 'IntAluOp'],{})

    inline Unpkbw::Unpkbw(ExtMachInst machInst)
         : AlphaStaticInst("unpkbw", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::unpkbl(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<15:8> << 32));\n                           ', 'IntAluOp'],{})

    inline Unpkbl::Unpkbl(ExtMachInst machInst)
         : AlphaStaticInst("unpkbl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::pkwb(['\n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<23:16> << 8)\n                                   | (Rb_uq<39:32> << 16)\n                                   | (Rb_uq<55:48> << 24));\n                           ', 'IntAluOp'],{})

    inline Pkwb::Pkwb(ExtMachInst machInst)
         : AlphaStaticInst("pkwb", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::pklb(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<39:32> << 8));\n                           ', 'IntAluOp'],{})

    inline Pklb::Pklb(ExtMachInst machInst)
         : AlphaStaticInst("pklb", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::minsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb < rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Minsb8::Minsb8(ExtMachInst machInst)
         : AlphaStaticInst("minsb8", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::minsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Minsw4::Minsw4(ExtMachInst machInst)
         : AlphaStaticInst("minsw4", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::minub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub < rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Minub8::Minub8(ExtMachInst machInst)
         : AlphaStaticInst("minub8", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::minuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_sw = Ra_uq<hi:lo>;\n                                 uint16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Minuw4::Minuw4(ExtMachInst machInst)
         : AlphaStaticInst("minuw4", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::maxub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub > rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Maxub8::Maxub8(ExtMachInst machInst)
         : AlphaStaticInst("maxub8", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::maxuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_uw = Ra_uq<hi:lo>;\n                                 uint16_t rb_uw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_uw > rb_uw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Maxuw4::Maxuw4(ExtMachInst machInst)
         : AlphaStaticInst("maxuw4", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::maxsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb > rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Maxsb8::Maxsb8(ExtMachInst machInst)
         : AlphaStaticInst("maxsb8", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// IntegerOperate::maxsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw > rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    inline Maxsw4::Maxsw4(ExtMachInst machInst)
         : AlphaStaticInst("maxsw4", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// BasicOperateWithNopCheck::ftoit([' Rc = Fa_uq; ', 'FloatCvtOp'],{})

    inline Ftoit::Ftoit(ExtMachInst machInst)
         : AlphaStaticInst("ftoit", machInst, FloatCvtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::ftois([' Rc_sl = t_to_s(Fa_uq); ', 'FloatCvtOp'],{})

    inline Ftois::Ftois(ExtMachInst machInst)
         : AlphaStaticInst("ftois", machInst, FloatCvtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RC] : RC;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CondBranch::beq([' cond = (Ra == 0); '],{})

    inline Beq::Beq(ExtMachInst machInst)
         : Branch("beq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::bne([' cond = (Ra != 0); '],{})

    inline Bne::Bne(ExtMachInst machInst)
         : Branch("bne", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::bge([' cond = (Ra_sq >= 0); '],{})

    inline Bge::Bge(ExtMachInst machInst)
         : Branch("bge", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::bgt([' cond = (Ra_sq >  0); '],{})

    inline Bgt::Bgt(ExtMachInst machInst)
         : Branch("bgt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::ble([' cond = (Ra_sq <= 0); '],{})

    inline Ble::Ble(ExtMachInst machInst)
         : Branch("ble", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::blt([' cond = (Ra_sq < 0); '],{})

    inline Blt::Blt(ExtMachInst machInst)
         : Branch("blt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::blbc([' cond = ((Ra & 1) == 0); '],{})

    inline Blbc::Blbc(ExtMachInst machInst)
         : Branch("blbc", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::blbs([' cond = ((Ra & 1) == 1); '],{})

    inline Blbs::Blbs(ExtMachInst machInst)
         : Branch("blbs", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

// CondBranch::fbeq([' cond = (Fa == 0); '],{})

    inline Fbeq::Fbeq(ExtMachInst machInst)
         : Branch("fbeq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// CondBranch::fbne([' cond = (Fa != 0); '],{})

    inline Fbne::Fbne(ExtMachInst machInst)
         : Branch("fbne", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// CondBranch::fbge([' cond = (Fa >= 0); '],{})

    inline Fbge::Fbge(ExtMachInst machInst)
         : Branch("fbge", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// CondBranch::fbgt([' cond = (Fa >  0); '],{})

    inline Fbgt::Fbgt(ExtMachInst machInst)
         : Branch("fbgt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// CondBranch::fble([' cond = (Fa <= 0); '],{})

    inline Fble::Fble(ExtMachInst machInst)
         : Branch("fble", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// CondBranch::fblt([' cond = (Fa < 0); '],{})

    inline Fblt::Fblt(ExtMachInst machInst)
         : Branch("fblt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsFloating] = true;;
    }

// UncondBranch::br([],{})

    inline Br::Br(ExtMachInst machInst)
         : Branch("br", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
    }

    inline BrAndLink::BrAndLink(ExtMachInst machInst)
         : Branch("br", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// UncondBranch::bsr(['IsCall'],{})

    inline Bsr::Bsr(ExtMachInst machInst)
         : Branch("bsr", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
    }

    inline BsrAndLink::BsrAndLink(ExtMachInst machInst)
         : Branch("bsr", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// Jump::jmp([],{})

    inline Jmp::Jmp(ExtMachInst machInst)
         : Jump("jmp", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    inline JmpAndLink::JmpAndLink(ExtMachInst machInst)
         : Jump("jmp", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// Jump::jsr(['IsCall'],{})

    inline Jsr::Jsr(ExtMachInst machInst)
         : Jump("jsr", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    inline JsrAndLink::JsrAndLink(ExtMachInst machInst)
         : Jump("jsr", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// Jump::ret(['IsReturn'],{})

    inline Ret::Ret(ExtMachInst machInst)
         : Jump("ret", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

    inline RetAndLink::RetAndLink(ExtMachInst machInst)
         : Jump("ret", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

// Jump::jsr_coroutine(['IsCall', 'IsReturn'],{})

    inline Jsr_coroutine::Jsr_coroutine(ExtMachInst machInst)
         : Jump("jsr_coroutine", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

    inline Jsr_coroutineAndLink::Jsr_coroutineAndLink(ExtMachInst machInst)
         : Jump("jsr_coroutine", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::itofs([' Fc_uq = s_to_t(Ra_ul); ', 'FloatCvtOp'],{})

    inline Itofs::Itofs(ExtMachInst machInst)
         : AlphaStaticInst("itofs", machInst, FloatCvtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// BasicOperateWithNopCheck::itoft([' Fc_uq = Ra_uq; ', 'FloatCvtOp'],{})

    inline Itoft::Itoft(ExtMachInst machInst)
         : AlphaStaticInst("itoft", machInst, FloatCvtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FailUnimpl::itoff(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::sqrts(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    inline Sqrts::Sqrts(ExtMachInst machInst)
         : AlphaFP("sqrts", machInst, FloatSqrtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }
#else

// FloatingPointOperate::sqrts(['\n                        if (Fb_sf < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc_sf = sqrt(Fb_sf);\n                    ', 'FloatSqrtOp'],{})

    inline Sqrts::Sqrts(ExtMachInst machInst)
         : AlphaFP("sqrts", machInst, FloatSqrtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }
#endif

// FloatingPointOperate::sqrtt(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    inline Sqrtt::Sqrtt(ExtMachInst machInst)
         : AlphaFP("sqrtt", machInst, FloatSqrtOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FailUnimpl::sqrtfg(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::adds([' Fc = Fa + Fb; '],{})

    inline Adds::Adds(ExtMachInst machInst)
         : AlphaFP("adds", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::subs([' Fc = Fa - Fb; '],{})

    inline Subs::Subs(ExtMachInst machInst)
         : AlphaFP("subs", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::muls([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    inline Muls::Muls(ExtMachInst machInst)
         : AlphaFP("muls", machInst, FloatMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::divs([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    inline Divs::Divs(ExtMachInst machInst)
         : AlphaFP("divs", machInst, FloatDivOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }
#else

// FloatingPointOperate::adds([' Fc_sf = Fa_sf + Fb_sf; '],{})

    inline Adds::Adds(ExtMachInst machInst)
         : AlphaFP("adds", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::subs([' Fc_sf = Fa_sf - Fb_sf; '],{})

    inline Subs::Subs(ExtMachInst machInst)
         : AlphaFP("subs", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::muls([' Fc_sf = Fa_sf * Fb_sf; ', 'FloatMultOp'],{})

    inline Muls::Muls(ExtMachInst machInst)
         : AlphaFP("muls", machInst, FloatMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::divs([' Fc_sf = Fa_sf / Fb_sf; ', 'FloatDivOp'],{})

    inline Divs::Divs(ExtMachInst machInst)
         : AlphaFP("divs", machInst, FloatDivOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }
#endif

// FloatingPointOperate::addt([' Fc = Fa + Fb; '],{})

    inline Addt::Addt(ExtMachInst machInst)
         : AlphaFP("addt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::subt([' Fc = Fa - Fb; '],{})

    inline Subt::Subt(ExtMachInst machInst)
         : AlphaFP("subt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::mult([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    inline Mult::Mult(ExtMachInst machInst)
         : AlphaFP("mult", machInst, FloatMultOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::divt([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    inline Divt::Divt(ExtMachInst machInst)
         : AlphaFP("divt", machInst, FloatDivOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cmpteq([' Fc = (Fa == Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    inline Cmpteq::Cmpteq(ExtMachInst machInst)
         : AlphaStaticInst("cmpteq", machInst, FloatCmpOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cmptle([' Fc = (Fa <= Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    inline Cmptle::Cmptle(ExtMachInst machInst)
         : AlphaStaticInst("cmptle", machInst, FloatCmpOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cmptlt([' Fc = (Fa <  Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    inline Cmptlt::Cmptlt(ExtMachInst machInst)
         : AlphaStaticInst("cmptlt", machInst, FloatCmpOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cmptun([' // unordered\n                    Fc = (!(Fa < Fb) && !(Fa == Fb) && !(Fa > Fb)) ? 2.0 : 0.0;\n                ', 'FloatCmpOp'],{})

    inline Cmptun::Cmptun(ExtMachInst machInst)
         : AlphaStaticInst("cmptun", machInst, FloatCmpOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)trunc(Fb); ', 'Chopped'],{})

    inline CvttqChopped::CvttqChopped(ExtMachInst machInst)
         : AlphaFP("cvttq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)floor(Fb); ', 'MinusInfinity'],{})

    inline CvttqMinusInfinity::CvttqMinusInfinity(ExtMachInst machInst)
         : AlphaFP("cvttq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::cvttq([' Fc_sq = (int64_t)nearbyint(Fb); '],{})

    inline Cvttq::Cvttq(ExtMachInst machInst)
         : AlphaFP("cvttq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cvtst([' Fc = Fb_sf; '],{})

    inline Cvtst::Cvtst(ExtMachInst machInst)
         : AlphaStaticInst("cvtst", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::cvtts([' Fc_sf = Fb; '],{})

    inline Cvtts::Cvtts(ExtMachInst machInst)
         : AlphaFP("cvtts", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// FloatingPointOperate::cvtqs([' Fc_sf = Fb_sq; '],{})

    inline Cvtqs::Cvtqs(ExtMachInst machInst)
         : AlphaFP("cvtqs", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FloatingPointOperate::cvtqt([' Fc    = Fb_sq; '],{})

    inline Cvtqt::Cvtqt(ExtMachInst machInst)
         : AlphaFP("cvtqt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cvtlq(['\n                Fc_sl = (Fb_uq<63:62> << 30) | Fb_uq<58:29>;\n            '],{})

    inline Cvtlq::Cvtlq(ExtMachInst machInst)
         : AlphaStaticInst("cvtlq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cvtql(['\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    inline Cvtql::Cvtql(ExtMachInst machInst)
         : AlphaStaticInst("cvtql", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cvtqlv(['\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = Fb_uq<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    inline Cvtqlv::Cvtqlv(ExtMachInst machInst)
         : AlphaStaticInst("cvtqlv", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cpys(['  // copy sign\n                Fc_uq = (Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    inline Cpys::Cpys(ExtMachInst machInst)
         : AlphaStaticInst("cpys", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cpysn([' // copy sign negated\n                Fc_uq = (~Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    inline Cpysn::Cpysn(ExtMachInst machInst)
         : AlphaStaticInst("cpysn", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::cpyse([' // copy sign and exponent\n                Fc_uq = (Fa_uq<63:52> << 52) | Fb_uq<51:0>;\n            '],{})

    inline Cpyse::Cpyse(ExtMachInst machInst)
         : AlphaStaticInst("cpyse", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmoveq([' Fc = (Fa == 0) ? Fb : Fc; '],{})

    inline Fcmoveq::Fcmoveq(ExtMachInst machInst)
         : AlphaStaticInst("fcmoveq", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmovne([' Fc = (Fa != 0) ? Fb : Fc; '],{})

    inline Fcmovne::Fcmovne(ExtMachInst machInst)
         : AlphaStaticInst("fcmovne", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmovlt([' Fc = (Fa <  0) ? Fb : Fc; '],{})

    inline Fcmovlt::Fcmovlt(ExtMachInst machInst)
         : AlphaStaticInst("fcmovlt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmovge([' Fc = (Fa >= 0) ? Fb : Fc; '],{})

    inline Fcmovge::Fcmovge(ExtMachInst machInst)
         : AlphaStaticInst("fcmovge", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmovle([' Fc = (Fa <= 0) ? Fb : Fc; '],{})

    inline Fcmovle::Fcmovle(ExtMachInst machInst)
         : AlphaStaticInst("fcmovle", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::fcmovgt([' Fc = (Fa >  0) ? Fb : Fc; '],{})

    inline Fcmovgt::Fcmovgt(ExtMachInst machInst)
         : AlphaStaticInst("fcmovgt", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FB + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FC + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = FC + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

// BasicOperateWithNopCheck::mt_fpcr([' FPCR = Fa_uq; ', 'IsIprAccess'],{})

    inline Mt_fpcr::Mt_fpcr(ExtMachInst machInst)
         : AlphaStaticInst("mt_fpcr", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_FPCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = FA + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsIprAccess] = true;;
    }

// BasicOperateWithNopCheck::mf_fpcr([' Fa_uq = FPCR; ', 'IsIprAccess'],{})

    inline Mf_fpcr::Mf_fpcr(ExtMachInst machInst)
         : AlphaStaticInst("mf_fpcr", machInst, FloatAddOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = FA + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsIprAccess] = true;;
    }

// Unknown::unknown(([], {}))

// WarnUnimpl::fetch([],{})

// WarnUnimpl::fetch_m([],{})

// WarnUnimpl::ecb([],{})

// MiscPrefetch::wh64([' EA = Rb & ~ULL(63); ', ' ; '],{'mem_flags': 'PREFETCH'})

    inline Wh64::Wh64(ExtMachInst machInst)
         : MemoryNoDisp("wh64", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	memAccessFlags = Request::PREFETCH;;
    }

// BasicOperate::rpcc(['\n                /* Rb is a fake dependency so here is a fun way to get\n                 * the parser to understand that.\n                 */\n                uint64_t unused_var M5_VAR_USED = Rb;\n                Ra = FullSystem ? xc->readMiscReg(IPR_CC) : curTick();\n            ', 'IsUnverifiable'],{})

    inline Rpcc::Rpcc(ExtMachInst machInst)
         : AlphaStaticInst("rpcc", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsUnverifiable] = true;;
    }

// BasicOperate::trapb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    inline Trapb::Trapb(ExtMachInst machInst)
         : AlphaStaticInst("trapb", machInst, No_OpClass)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;;
    }

// BasicOperate::excb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    inline Excb::Excb(ExtMachInst machInst)
         : AlphaStaticInst("excb", machInst, No_OpClass)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;;
    }

// BasicOperate::mb([' ', 'IsMemBarrier', 'MemReadOp'],{})

    inline Mb::Mb(ExtMachInst machInst)
         : AlphaStaticInst("mb", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMemBarrier] = true;;
    }

// BasicOperate::wmb([' ', 'IsWriteBarrier', 'MemWriteOp'],{})

    inline Wmb::Wmb(ExtMachInst machInst)
         : AlphaStaticInst("wmb", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsWriteBarrier] = true;;
    }

// FailUnimpl::rc_se(([], {}))

// BasicOperate::rc((['\n                Ra = IntrFlag;\n                IntrFlag = 0;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    inline Rc::Rc(ExtMachInst machInst)
         : AlphaStaticInst("rc", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_INTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_INTR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
    }

// FailUnimpl::rs_se(([], {}))

// BasicOperate::rs((['\n                Ra = IntrFlag;\n                IntrFlag = 1;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    inline Rs::Rs(ExtMachInst machInst)
         : AlphaStaticInst("rs", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_INTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_INTR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
    }

// Unknown::unknown(([], {}))

// EmulatedCallPal::halt(['\n                    exitSimLoop("halt instruction encountered");\n                ', 'IsNonSpeculative'],{})

    inline Halt::Halt(ExtMachInst machInst)
         : EmulatedCallPal("halt", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// EmulatedCallPal::callsys(['\n                    xc->syscall(R0);\n                ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall'],{})

    inline Callsys::Callsys(ExtMachInst machInst)
         : EmulatedCallPal("callsys", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
    }

// EmulatedCallPal::rduniq([' R0 = Runiq; ', 'IsIprAccess'],{})

    inline Rduniq::Rduniq(ExtMachInst machInst)
         : EmulatedCallPal("rduniq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_UNIQ + Misc_Reg_Base;
	flags[IsIprAccess] = true;;
    }

// EmulatedCallPal::wruniq([' Runiq = R16; ', 'IsIprAccess'],{})

    inline Wruniq::Wruniq(ExtMachInst machInst)
         : EmulatedCallPal("wruniq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_UNIQ + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 16;
	flags[IsIprAccess] = true;;
    }

// Unknown::unknown(([], {}))

// CallPal::call_pal((['\n            if (!palValid ||\n                (palPriv\n                 && xc->readMiscReg(IPR_ICM) != mode_kernel)) {\n                // invalid pal function code, or attempt to do privileged\n                // PAL call in non-kernel mode\n                fault = new UnimplementedOpcodeFault;\n            } else {\n                // check to see if simulator wants to do something special\n                // on this PAL call (including maybe suppress it)\n                bool dopal = xc->simPalCheck(palFunc);\n\n                if (dopal) {\n                    xc->setMiscReg(IPR_EXC_ADDR, NPC);\n                    NPC = xc->readMiscReg(IPR_PAL_BASE) + palOffset;\n                }\n            }\n        ', 'IsNonSpeculative'], {}))

    inline Call_pal::Call_pal(ExtMachInst machInst)
         : CallPalBase("call_pal", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;;
    }

// OpcdecFault::hw_st_quad(([], {}))

// HwLoad::hw_ld([' EA = (Rb + disp) & ~3; ', ' Ra = Mem_ul; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    inline Hw_ldL::Hw_ldL(ExtMachInst machInst)
         : HwLoadStore("hw_ld", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;;
    }

// HwLoad::hw_ld([' EA = (Rb + disp) & ~7; ', ' Ra = Mem_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    inline Hw_ldQ::Hw_ldQ(ExtMachInst machInst)
         : HwLoadStore("hw_ld", machInst, MemReadOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_st_cond(([], {}))

// HwStore::hw_st([' EA = (Rb + disp) & ~3; ', ' Mem_ul = Ra<31:0>; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    inline Hw_stL::Hw_stL(ExtMachInst machInst)
         : HwLoadStore("hw_st", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;
	flags[IsStore] = true;;
    }

// HwStore::hw_st([' EA = (Rb + disp) & ~7; ', ' Mem_uq = Ra_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    inline Hw_stQ::Hw_stQ(ExtMachInst machInst)
         : HwLoadStore("hw_st", machInst, MemWriteOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RB] : RB;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;
	flags[IsStore] = true;;
    }

// Unknown::unknown(([], {}))

// FailUnimpl::hw_st_cond(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mfpr(([], {}))

// HwMoveIPR::hw_mfpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsReadable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    Ra = xc->readMiscReg(miscRegIndex);\n            ', 'IsIprAccess'],{})

    inline Hw_mfpr::Hw_mfpr(ExtMachInst machInst)
         : HwMoveIPR("hw_mfpr", machInst, IprAccessOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsIprAccess] = true;;
    }

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mtpr(([], {}))

// HwMoveIPR::hw_mtpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsWritable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    xc->setMiscReg(miscRegIndex, Ra);\n                if (traceData) { traceData->setData(Ra); }\n            ', 'IsIprAccess'],{})

    inline Hw_mtpr::Hw_mtpr(ExtMachInst machInst)
         : HwMoveIPR("hw_mtpr", machInst, IprAccessOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = PALMODE ? reg_redir[RA] : RA;
	flags[IsInteger] = true;
	flags[IsIprAccess] = true;;
    }

// Unknown::unknown(([], {}))

// OpcdecFault::hw_rei(([], {}))

// BasicOperate::hw_rei([' xc->hwrei(); ', 'IsSerializing', 'IsSerializeBefore'],{})

    inline Hw_rei::Hw_rei(ExtMachInst machInst)
         : AlphaStaticInst("hw_rei", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsSerializeBefore] = true;
	flags[IsSerializing] = true;;
    }

// Unknown::unknown(([], {}))

// BasicOperate::arm(['\n                PseudoInst::arm(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    inline Arm::Arm(ExtMachInst machInst)
         : AlphaStaticInst("arm", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::quiesce(["\n                // Don't sleep if (unmasked) interrupts are pending\n                Interrupts* interrupts =\n                    xc->tcBase()->getCpuPtr()->getInterruptController();\n                if (interrupts->checkInterrupts(xc->tcBase())) {\n                    PseudoInst::quiesceSkip(xc->tcBase());\n                } else {\n                    PseudoInst::quiesce(xc->tcBase());\n                }\n            ", 'IsNonSpeculative', 'IsQuiesce'],{})

    inline Quiesce::Quiesce(ExtMachInst machInst)
         : AlphaStaticInst("quiesce", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
    }

// BasicOperate::quiesceNs(['\n                PseudoInst::quiesceNs(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce'],{})

    inline QuiesceNs::QuiesceNs(ExtMachInst machInst)
         : AlphaStaticInst("quiesceNs", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
    }

// BasicOperate::quiesceCycles(['\n                PseudoInst::quiesceCycles(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce', 'IsUnverifiable'],{})

    inline QuiesceCycles::QuiesceCycles(ExtMachInst machInst)
         : AlphaStaticInst("quiesceCycles", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsUnverifiable] = true;;
    }

// BasicOperate::quiesceTime(['\n                R0 = PseudoInst::quiesceTime(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    inline QuiesceTime::QuiesceTime(ExtMachInst machInst)
         : AlphaStaticInst("quiesceTime", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
    }

// BasicOperate::rpns(['\n                R0 = PseudoInst::rpns(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    inline Rpns::Rpns(ExtMachInst machInst)
         : AlphaStaticInst("rpns", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
    }

// BasicOperate::wakeCPU(['\n                PseudoInst::wakeCPU(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    inline WakeCPU::WakeCPU(ExtMachInst machInst)
         : AlphaStaticInst("wakeCPU", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
    }

// BasicOperate::deprecated_ivlb(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    inline Deprecated_ivlb::Deprecated_ivlb(ExtMachInst machInst)
         : AlphaStaticInst("deprecated_ivlb", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

// BasicOperate::deprecated_ivle(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    inline Deprecated_ivle::Deprecated_ivle(ExtMachInst machInst)
         : AlphaStaticInst("deprecated_ivle", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

// BasicOperate::deprecated_exit(['\n                warn_once("deprecated M5 exit instruction encountered.\\n");\n                PseudoInst::m5exit(xc->tcBase(), 0);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    inline Deprecated_exit::Deprecated_exit(ExtMachInst machInst)
         : AlphaStaticInst("deprecated_exit", machInst, No_OpClass)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5exit(['\n                PseudoInst::m5exit(xc->tcBase(), R16);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    inline M5exit::M5exit(ExtMachInst machInst)
         : AlphaStaticInst("m5exit", machInst, No_OpClass)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::loadsymbol(['\n                PseudoInst::loadsymbol(xc->tcBase());\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    inline Loadsymbol::Loadsymbol(ExtMachInst machInst)
         : AlphaStaticInst("loadsymbol", machInst, No_OpClass)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::initparam(['\n                Ra = PseudoInst::initParam(xc->tcBase());\n            '],{})

    inline Initparam::Initparam(ExtMachInst machInst)
         : AlphaStaticInst("initparam", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = PALMODE ? reg_redir[RA] : RA;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

// BasicOperate::resetstats(['\n                PseudoInst::resetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    inline Resetstats::Resetstats(ExtMachInst machInst)
         : AlphaStaticInst("resetstats", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::dumpstats(['\n                PseudoInst::dumpstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    inline Dumpstats::Dumpstats(ExtMachInst machInst)
         : AlphaStaticInst("dumpstats", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::dumpresetstats(['\n                PseudoInst::dumpresetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    inline Dumpresetstats::Dumpresetstats(ExtMachInst machInst)
         : AlphaStaticInst("dumpresetstats", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5checkpoint(['\n                PseudoInst::m5checkpoint(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    inline M5checkpoint::M5checkpoint(ExtMachInst machInst)
         : AlphaStaticInst("m5checkpoint", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5readfile(['\n                R0 = PseudoInst::readfile(xc->tcBase(), R16, R17, R18);\n            ', 'IsNonSpeculative'],{})

    inline M5readfile::M5readfile(ExtMachInst machInst)
         : AlphaStaticInst("m5readfile", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	_srcRegIdx[_numSrcRegs++] = 18;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5break(['\n                PseudoInst::debugbreak(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    inline M5break::M5break(ExtMachInst machInst)
         : AlphaStaticInst("m5break", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5switchcpu(['\n                PseudoInst::switchcpu(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    inline M5switchcpu::M5switchcpu(ExtMachInst machInst)
         : AlphaStaticInst("m5switchcpu", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5addsymbol(['\n                PseudoInst::addsymbol(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    inline M5addsymbol::M5addsymbol(ExtMachInst machInst)
         : AlphaStaticInst("m5addsymbol", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = 16;
	_srcRegIdx[_numSrcRegs++] = 17;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5panic(['\n                panic("M5 panic instruction called at pc = %#x.", PC);\n            ', 'IsNonSpeculative'],{})

    inline M5panic::M5panic(ExtMachInst machInst)
         : AlphaStaticInst("m5panic", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }
#define  CPANN(lbl) CPA::cpa()->lbl(xc->tcBase())

// BasicOperate::m5a_old(['\n                    panic("Deprecated M5 annotate instruction executed "\n                          "at pc = %#x\\n", PC);\n                ', 'IsNonSpeculative'],{})

    inline M5a_old::M5a_old(ExtMachInst machInst)
         : AlphaStaticInst("m5a_old", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_bsm(['\n                    CPANN(swSmBegin);\n                ', 'IsNonSpeculative'],{})

    inline M5a_bsm::M5a_bsm(ExtMachInst machInst)
         : AlphaStaticInst("m5a_bsm", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_esm(['\n                    CPANN(swSmEnd);\n                ', 'IsNonSpeculative'],{})

    inline M5a_esm::M5a_esm(ExtMachInst machInst)
         : AlphaStaticInst("m5a_esm", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_begin(['\n                    CPANN(swExplictBegin);\n                ', 'IsNonSpeculative'],{})

    inline M5a_begin::M5a_begin(ExtMachInst machInst)
         : AlphaStaticInst("m5a_begin", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_end(['\n                    CPANN(swEnd);\n                ', 'IsNonSpeculative'],{})

    inline M5a_end::M5a_end(ExtMachInst machInst)
         : AlphaStaticInst("m5a_end", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_q(['\n                    CPANN(swQ);\n                ', 'IsNonSpeculative'],{})

    inline M5a_q::M5a_q(ExtMachInst machInst)
         : AlphaStaticInst("m5a_q", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_dq(['\n                    CPANN(swDq);\n                ', 'IsNonSpeculative'],{})

    inline M5a_dq::M5a_dq(ExtMachInst machInst)
         : AlphaStaticInst("m5a_dq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_wf(['\n                    CPANN(swWf);\n                ', 'IsNonSpeculative'],{})

    inline M5a_wf::M5a_wf(ExtMachInst machInst)
         : AlphaStaticInst("m5a_wf", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_we(['\n                    CPANN(swWe);\n                ', 'IsNonSpeculative'],{})

    inline M5a_we::M5a_we(ExtMachInst machInst)
         : AlphaStaticInst("m5a_we", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_sq(['\n                    CPANN(swSq);\n                ', 'IsNonSpeculative'],{})

    inline M5a_sq::M5a_sq(ExtMachInst machInst)
         : AlphaStaticInst("m5a_sq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_aq(['\n                    CPANN(swAq);\n                ', 'IsNonSpeculative'],{})

    inline M5a_aq::M5a_aq(ExtMachInst machInst)
         : AlphaStaticInst("m5a_aq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_pq(['\n                    CPANN(swPq);\n                ', 'IsNonSpeculative'],{})

    inline M5a_pq::M5a_pq(ExtMachInst machInst)
         : AlphaStaticInst("m5a_pq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_l(['\n                    CPANN(swLink);\n                ', 'IsNonSpeculative'],{})

    inline M5a_l::M5a_l(ExtMachInst machInst)
         : AlphaStaticInst("m5a_l", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_identify(['\n                    CPANN(swIdentify);\n                ', 'IsNonSpeculative'],{})

    inline M5a_identify::M5a_identify(ExtMachInst machInst)
         : AlphaStaticInst("m5a_identify", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_getid(['\n                    R0 = CPANN(swGetId);\n                ', 'IsNonSpeculative'],{})

    inline M5a_getid::M5a_getid(ExtMachInst machInst)
         : AlphaStaticInst("m5a_getid", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_scl(['\n                    CPANN(swSyscallLink);\n                ', 'IsNonSpeculative'],{})

    inline M5a_scl::M5a_scl(ExtMachInst machInst)
         : AlphaStaticInst("m5a_scl", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5a_rq(['\n                    CPANN(swRq);\n                ', 'IsNonSpeculative'],{})

    inline M5a_rq::M5a_rq(ExtMachInst machInst)
         : AlphaStaticInst("m5a_rq", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// Unknown::unknown(([], {}))
#undef CPANN

// BasicOperate::m5reserved2(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    inline M5reserved2::M5reserved2(ExtMachInst machInst)
         : AlphaStaticInst("m5reserved2", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5reserved3(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    inline M5reserved3::M5reserved3(ExtMachInst machInst)
         : AlphaStaticInst("m5reserved3", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5reserved4(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    inline M5reserved4::M5reserved4(ExtMachInst machInst)
         : AlphaStaticInst("m5reserved4", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// BasicOperate::m5reserved5(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    inline M5reserved5::M5reserved5(ExtMachInst machInst)
         : AlphaStaticInst("m5reserved5", machInst, IntAluOp)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))


} // namespace AlphaISAInst


StaticInstPtr
AlphaISA::Decoder::decodeInst(AlphaISA::ExtMachInst machInst)
{
    using namespace AlphaISAInst;
  switch (OPCODE) {
    
    case 0x8:  
      // LoadAddress::lda([' Ra = Rb + disp; '],{})
      
          return new Lda(machInst);
      break;
    
    case 0x9:  
      // LoadAddress::ldah([' Ra = Rb + (disp << 16); '],{})
      
          return new Ldah(machInst);
      break;
    
    case 0xa:  
      // LoadOrNop::ldbu([' Ra_uq = Mem_ub; '],{})
      
       {
           AlphaStaticInst *i = new Ldbu(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0xc:  
      // LoadOrNop::ldwu([' Ra_uq = Mem_uw; '],{})
      
       {
           AlphaStaticInst *i = new Ldwu(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0xb:  
      // LoadOrNop::ldq_u([' Ra = Mem_uq; '],{'ea_code': ' EA = (Rb + disp) & ~7; '})
      
       {
           AlphaStaticInst *i = new Ldq_u(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0x23:  
      // LoadOrNop::ldt([' Fa = Mem_df; '],{})
      
       {
           AlphaStaticInst *i = new Ldt(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0x2a:  
      // LoadOrNop::ldl_l([' Ra_sl = Mem_sl; '],{'mem_flags': 'LLSC'})
      
       {
           AlphaStaticInst *i = new Ldl_l(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0x2b:  
      // LoadOrNop::ldq_l([' Ra_uq = Mem_uq; '],{'mem_flags': 'LLSC'})
      
       {
           AlphaStaticInst *i = new Ldq_l(machInst);
           if (RA == 31) {
               i = makeNop(i);
           }
           return i;
       }
      break;
    
    case 0x28:  
      // LoadOrPrefetch::ldl([' Ra_sl = Mem_sl; '],{})
      
       {
           if (RA != 31) {
               return new Ldl(machInst);
           }
           else {
               return new LdlPrefetch(machInst);
           }
       }
      break;
    
    case 0x29:  
      // LoadOrPrefetch::ldq([' Ra_uq = Mem_uq; '],{'pf_flags': 'EVICT_NEXT'})
      
       {
           if (RA != 31) {
               return new Ldq(machInst);
           }
           else {
               return new LdqPrefetch(machInst);
           }
       }
      break;
    
    case 0x22:  
      // LoadOrPrefetch::lds([' Fa_uq = s_to_t(Mem_ul); '],{'pf_flags': 'PF_EXCLUSIVE', 'inst_flags': 'IsFloating'})
      
       {
           if (RA != 31) {
               return new Lds(machInst);
           }
           else {
               return new LdsPrefetch(machInst);
           }
       }
      break;
    
    case 0xe:  
      // Store::stb([' Mem_ub = Ra<7:0>; '],{})
      
          return new Stb(machInst);
      break;
    
    case 0xd:  
      // Store::stw([' Mem_uw = Ra<15:0>; '],{})
      
          return new Stw(machInst);
      break;
    
    case 0x2c:  
      // Store::stl([' Mem_ul = Ra<31:0>; '],{})
      
          return new Stl(machInst);
      break;
    
    case 0x2d:  
      // Store::stq([' Mem_uq = Ra_uq; '],{})
      
          return new Stq(machInst);
      break;
    
    case 0xf:  
      // Store::stq_u([' Mem_uq = Ra_uq; ', ' EA = (Rb + disp) & ~7; '],{})
      
          return new Stq_u(machInst);
      break;
    
    case 0x26:  
      // Store::sts([' Mem_ul = t_to_s(Fa_uq); '],{})
      
          return new Sts(machInst);
      break;
    
    case 0x27:  
      // Store::stt([' Mem_df = Fa; '],{})
      
          return new Stt(machInst);
      break;
    
    case 0x2e:  
      // StoreCond::stl_c([' Mem_ul = Ra<31:0>; ', '\n                        uint64_t tmp = write_result;\n                        // see stq_c\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            xc->setStCondFailures(0);\n                        }\n                    '],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})
      
          return new Stl_c(machInst);
      break;
    
    case 0x2f:  
      // StoreCond::stq_c([' Mem_uq = Ra; ', "\n                        uint64_t tmp = write_result;\n                        // If the write operation returns 0 or 1, then\n                        // this was a conventional store conditional,\n                        // and the value indicates the success/failure\n                        // of the operation.  If another value is\n                        // returned, then this was a Turbolaser\n                        // mailbox access, and we don't update the\n                        // result register at all.\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            // clear failure counter... this is\n                            // non-architectural and for debugging\n                            // only.\n                            xc->setStCondFailures(0);\n                        }\n                    "],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})
      
          return new Stq_c(machInst);
      break;
    
    case 0x10:
      switch (INTFUNC) {
        
        case 0x0:  
          // IntegerOperate::addl([' Rc_sl = Ra_sl + Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new AddlImm(machInst)
                         : (AlphaStaticInst *)new Addl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x40:  
          // IntegerOperate::addlv(['\n                int32_t tmp  = Ra_sl + Rb_or_imm_sl;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra_sl<31:> == Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new AddlvImm(machInst)
                         : (AlphaStaticInst *)new Addlv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2:  
          // IntegerOperate::s4addl([' Rc_sl = (Ra_sl << 2) + Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S4addlImm(machInst)
                         : (AlphaStaticInst *)new S4addl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x12:  
          // IntegerOperate::s8addl([' Rc_sl = (Ra_sl << 3) + Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S8addlImm(machInst)
                         : (AlphaStaticInst *)new S8addl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x20:  
          // IntegerOperate::addq([' Rc = Ra + Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new AddqImm(machInst)
                         : (AlphaStaticInst *)new Addq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x60:  
          // IntegerOperate::addqv(['\n                uint64_t tmp = Ra + Rb_or_imm;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra<63:> == Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new AddqvImm(machInst)
                         : (AlphaStaticInst *)new Addqv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x22:  
          // IntegerOperate::s4addq([' Rc = (Ra << 2) + Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S4addqImm(machInst)
                         : (AlphaStaticInst *)new S4addq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x32:  
          // IntegerOperate::s8addq([' Rc = (Ra << 3) + Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S8addqImm(machInst)
                         : (AlphaStaticInst *)new S8addq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x9:  
          // IntegerOperate::subl([' Rc_sl = Ra_sl - Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SublImm(machInst)
                         : (AlphaStaticInst *)new Subl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x49:  
          // IntegerOperate::sublv(['\n                int32_t tmp  = Ra_sl - Rb_or_imm_sl;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra_sl<31:> != Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SublvImm(machInst)
                         : (AlphaStaticInst *)new Sublv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0xb:  
          // IntegerOperate::s4subl([' Rc_sl = (Ra_sl << 2) - Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S4sublImm(machInst)
                         : (AlphaStaticInst *)new S4subl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x1b:  
          // IntegerOperate::s8subl([' Rc_sl = (Ra_sl << 3) - Rb_or_imm_sl; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S8sublImm(machInst)
                         : (AlphaStaticInst *)new S8subl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x29:  
          // IntegerOperate::subq([' Rc = Ra - Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SubqImm(machInst)
                         : (AlphaStaticInst *)new Subq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x69:  
          // IntegerOperate::subqv(['\n                uint64_t tmp  = Ra - Rb_or_imm;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra<63:> != Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SubqvImm(machInst)
                         : (AlphaStaticInst *)new Subqv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2b:  
          // IntegerOperate::s4subq([' Rc = (Ra << 2) - Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S4subqImm(machInst)
                         : (AlphaStaticInst *)new S4subq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3b:  
          // IntegerOperate::s8subq([' Rc = (Ra << 3) - Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new S8subqImm(machInst)
                         : (AlphaStaticInst *)new S8subq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2d:  
          // IntegerOperate::cmpeq([' Rc = (Ra == Rb_or_imm); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpeqImm(machInst)
                         : (AlphaStaticInst *)new Cmpeq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x6d:  
          // IntegerOperate::cmple([' Rc = (Ra_sq <= Rb_or_imm_sq); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpleImm(machInst)
                         : (AlphaStaticInst *)new Cmple(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x4d:  
          // IntegerOperate::cmplt([' Rc = (Ra_sq <  Rb_or_imm_sq); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpltImm(machInst)
                         : (AlphaStaticInst *)new Cmplt(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3d:  
          // IntegerOperate::cmpule([' Rc = (Ra_uq <= Rb_or_imm_uq); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpuleImm(machInst)
                         : (AlphaStaticInst *)new Cmpule(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x1d:  
          // IntegerOperate::cmpult([' Rc = (Ra_uq <  Rb_or_imm_uq); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpultImm(machInst)
                         : (AlphaStaticInst *)new Cmpult(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0xf:  
          // IntegerOperate::cmpbge(['\n                int hi = 7;\n                int lo = 0;\n                uint64_t tmp = 0;\n                for (int i = 0; i < 8; ++i) {\n                    tmp |= (Ra_uq<hi:lo> >= Rb_or_imm_uq<hi:lo>) << i;\n                    hi += 8;\n                    lo += 8;\n                }\n                Rc = tmp;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmpbgeImm(machInst)
                         : (AlphaStaticInst *)new Cmpbge(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x11:
      switch (INTFUNC) {
        
        case 0x0:  
          // IntegerOperate::and([' Rc = Ra & Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new AndImm(machInst)
                         : (AlphaStaticInst *)new And(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x8:  
          // IntegerOperate::bic([' Rc = Ra & ~Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new BicImm(machInst)
                         : (AlphaStaticInst *)new Bic(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x20:  
          // IntegerOperate::bis([' Rc = Ra | Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new BisImm(machInst)
                         : (AlphaStaticInst *)new Bis(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x28:  
          // IntegerOperate::ornot([' Rc = Ra | ~Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new OrnotImm(machInst)
                         : (AlphaStaticInst *)new Ornot(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x40:  
          // IntegerOperate::xor([' Rc = Ra ^ Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new XorImm(machInst)
                         : (AlphaStaticInst *)new Xor(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x48:  
          // IntegerOperate::eqv([' Rc = Ra ^ ~Rb_or_imm; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new EqvImm(machInst)
                         : (AlphaStaticInst *)new Eqv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x14:  
          // IntegerOperate::cmovlbs([' Rc = ((Ra & 1) == 1) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovlbsImm(machInst)
                         : (AlphaStaticInst *)new Cmovlbs(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x16:  
          // IntegerOperate::cmovlbc([' Rc = ((Ra & 1) == 0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovlbcImm(machInst)
                         : (AlphaStaticInst *)new Cmovlbc(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x24:  
          // IntegerOperate::cmoveq([' Rc = (Ra == 0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmoveqImm(machInst)
                         : (AlphaStaticInst *)new Cmoveq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x26:  
          // IntegerOperate::cmovne([' Rc = (Ra != 0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovneImm(machInst)
                         : (AlphaStaticInst *)new Cmovne(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x44:  
          // IntegerOperate::cmovlt([' Rc = (Ra_sq <  0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovltImm(machInst)
                         : (AlphaStaticInst *)new Cmovlt(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x46:  
          // IntegerOperate::cmovge([' Rc = (Ra_sq >= 0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovgeImm(machInst)
                         : (AlphaStaticInst *)new Cmovge(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x64:  
          // IntegerOperate::cmovle([' Rc = (Ra_sq <= 0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovleImm(machInst)
                         : (AlphaStaticInst *)new Cmovle(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x66:  
          // IntegerOperate::cmovgt([' Rc = (Ra_sq >  0) ? Rb_or_imm : Rc; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new CmovgtImm(machInst)
                         : (AlphaStaticInst *)new Cmovgt(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x61:
          switch (RA) {
            
            case 0x1f:  
              // IntegerOperate::amask([' Rc = Rb_or_imm & ~ULL(0x17); '],{})
              
               {
                   AlphaStaticInst *i =
                       (IMM) ? (AlphaStaticInst *)new AmaskImm(machInst)
                             : (AlphaStaticInst *)new Amask(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x6c:
          switch (RA) {
            
            case 0x1f:
              switch (IMM) {
                
                case 0x1:
                  switch (INTIMM) {
                    
                    case 0x1:  
                      // IntegerOperate::implver([' Rc = FullSystem ? 1 : 2 '],{})
                      
                       {
                           AlphaStaticInst *i = new Implver(machInst);
                           if (RC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x25:  
          // WarnUnimpl::eleven25(([], {}))
          
              return new WarnUnimplemented("eleven25", machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x12:
      switch (INTFUNC) {
        
        case 0x39:  
          // IntegerOperate::sll([' Rc = Ra << Rb_or_imm<5:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SllImm(machInst)
                         : (AlphaStaticInst *)new Sll(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x34:  
          // IntegerOperate::srl([' Rc = Ra_uq >> Rb_or_imm<5:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SrlImm(machInst)
                         : (AlphaStaticInst *)new Srl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3c:  
          // IntegerOperate::sra([' Rc = Ra_sq >> Rb_or_imm<5:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new SraImm(machInst)
                         : (AlphaStaticInst *)new Sra(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2:  
          // IntegerOperate::mskbl([' Rc = Ra & ~(mask( 8) << (Rb_or_imm<2:0> * 8)); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskblImm(machInst)
                         : (AlphaStaticInst *)new Mskbl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x12:  
          // IntegerOperate::mskwl([' Rc = Ra & ~(mask(16) << (Rb_or_imm<2:0> * 8)); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskwlImm(machInst)
                         : (AlphaStaticInst *)new Mskwl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x22:  
          // IntegerOperate::mskll([' Rc = Ra & ~(mask(32) << (Rb_or_imm<2:0> * 8)); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskllImm(machInst)
                         : (AlphaStaticInst *)new Mskll(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x32:  
          // IntegerOperate::mskql([' Rc = Ra & ~(mask(64) << (Rb_or_imm<2:0> * 8)); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskqlImm(machInst)
                         : (AlphaStaticInst *)new Mskql(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x52:  
          // IntegerOperate::mskwh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskwhImm(machInst)
                         : (AlphaStaticInst *)new Mskwh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x62:  
          // IntegerOperate::msklh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MsklhImm(machInst)
                         : (AlphaStaticInst *)new Msklh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x72:  
          // IntegerOperate::mskqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MskqhImm(machInst)
                         : (AlphaStaticInst *)new Mskqh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x6:  
          // IntegerOperate::extbl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))< 7:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtblImm(machInst)
                         : (AlphaStaticInst *)new Extbl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x16:  
          // IntegerOperate::extwl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<15:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtwlImm(machInst)
                         : (AlphaStaticInst *)new Extwl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x26:  
          // IntegerOperate::extll([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<31:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtllImm(machInst)
                         : (AlphaStaticInst *)new Extll(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x36:  
          // IntegerOperate::extql([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8)); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtqlImm(machInst)
                         : (AlphaStaticInst *)new Extql(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x5a:  
          // IntegerOperate::extwh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<15:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtwhImm(machInst)
                         : (AlphaStaticInst *)new Extwh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x6a:  
          // IntegerOperate::extlh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<31:0>; '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtlhImm(machInst)
                         : (AlphaStaticInst *)new Extlh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x7a:  
          // IntegerOperate::extqh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ExtqhImm(machInst)
                         : (AlphaStaticInst *)new Extqh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0xb:  
          // IntegerOperate::insbl([' Rc = Ra< 7:0> << (Rb_or_imm<2:0> * 8); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InsblImm(machInst)
                         : (AlphaStaticInst *)new Insbl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x1b:  
          // IntegerOperate::inswl([' Rc = Ra<15:0> << (Rb_or_imm<2:0> * 8); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InswlImm(machInst)
                         : (AlphaStaticInst *)new Inswl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2b:  
          // IntegerOperate::insll([' Rc = Ra<31:0> << (Rb_or_imm<2:0> * 8); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InsllImm(machInst)
                         : (AlphaStaticInst *)new Insll(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3b:  
          // IntegerOperate::insql([' Rc = Ra       << (Rb_or_imm<2:0> * 8); '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InsqlImm(machInst)
                         : (AlphaStaticInst *)new Insql(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x57:  
          // IntegerOperate::inswh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<15:0> >> (64 - 8 * bv)) : 0;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InswhImm(machInst)
                         : (AlphaStaticInst *)new Inswh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x67:  
          // IntegerOperate::inslh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<31:0> >> (64 - 8 * bv)) : 0;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InslhImm(machInst)
                         : (AlphaStaticInst *)new Inslh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x77:  
          // IntegerOperate::insqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq       >> (64 - 8 * bv)) : 0;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new InsqhImm(machInst)
                         : (AlphaStaticInst *)new Insqh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x30:  
          // IntegerOperate::zap(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ZapImm(machInst)
                         : (AlphaStaticInst *)new Zap(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x31:  
          // IntegerOperate::zapnot(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (!Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new ZapnotImm(machInst)
                         : (AlphaStaticInst *)new Zapnot(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x13:
      switch (INTFUNC) {
        
        case 0x0:  
          // IntegerOperate::mull([' Rc_sl = Ra_sl * Rb_or_imm_sl; ', 'IntMultOp'],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MullImm(machInst)
                         : (AlphaStaticInst *)new Mull(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x20:  
          // IntegerOperate::mulq([' Rc    = Ra    * Rb_or_imm;    ', 'IntMultOp'],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MulqImm(machInst)
                         : (AlphaStaticInst *)new Mulq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x30:  
          // IntegerOperate::umulh(['\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                Rc = hi;\n            ', 'IntMultOp'],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new UmulhImm(machInst)
                         : (AlphaStaticInst *)new Umulh(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x40:  
          // IntegerOperate::mullv(['\n                // 32-bit multiply with trap on overflow\n                int64_t Rax = Ra_sl;    // sign extended version of Ra_sl\n                int64_t Rbx = Rb_or_imm_sl;\n                int64_t tmp = Rax * Rbx;\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = tmp<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp<31:0>;\n            ', 'IntMultOp'],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MullvImm(machInst)
                         : (AlphaStaticInst *)new Mullv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x60:  
          // IntegerOperate::mulqv(['\n                // 64-bit multiply with trap on overflow\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                // all the upper 64 bits must match the sign bit of\n                // the lower 64\n                if (!((hi == 0 && lo<63:> == 0) ||\n                      (hi == mask(64) && lo<63:> == 1)))\n                    fault = new IntegerOverflowFault;\n                Rc = lo;\n            ', 'IntMultOp'],{})
          
           {
               AlphaStaticInst *i =
                   (IMM) ? (AlphaStaticInst *)new MulqvImm(machInst)
                         : (AlphaStaticInst *)new Mulqv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x1c:
      switch (INTFUNC) {
        
        case 0x0:
          switch (RA) {
            
            case 0x1f:  
              // IntegerOperate::sextb([' Rc_sb = Rb_or_imm< 7:0>; '],{})
              
               {
                   AlphaStaticInst *i =
                       (IMM) ? (AlphaStaticInst *)new SextbImm(machInst)
                             : (AlphaStaticInst *)new Sextb(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x1:
          switch (RA) {
            
            case 0x1f:  
              // IntegerOperate::sextw([' Rc_sw = Rb_or_imm<15:0>; '],{})
              
               {
                   AlphaStaticInst *i =
                       (IMM) ? (AlphaStaticInst *)new SextwImm(machInst)
                             : (AlphaStaticInst *)new Sextw(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x30:  
          // IntegerOperate::ctpop(['\n                             uint64_t count = 0;\n                             for (int i = 0; Rb<63:i>; ++i) {\n                                 if (Rb<i:i> == 0x1)\n                                     ++count;\n                             }\n                             Rc = count;\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Ctpop(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x31:  
          // IntegerOperate::perr(['\n                             uint64_t temp = 0;\n                             int hi = 7;\n                             int lo = 0;\n                             for (int i = 0; i < 8; ++i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp += (ra_ub >= rb_ub) ? \n                                         (ra_ub - rb_ub) : (rb_ub - ra_ub);\n                                 hi += 8;\n                                 lo += 8;\n                             }\n                             Rc = temp;\n                           '],{})
          
           {
               AlphaStaticInst *i = new Perr(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x32:  
          // IntegerOperate::ctlz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (temp<63:32>) temp >>= 32; else count += 32;\n                             if (temp<31:16>) temp >>= 16; else count += 16;\n                             if (temp<15:8>) temp >>= 8; else count += 8;\n                             if (temp<7:4>) temp >>= 4; else count += 4;\n                             if (temp<3:2>) temp >>= 2; else count += 2;\n                             if (temp<1:1>) temp >>= 1; else count += 1;\n                             if ((temp<0:0>) != 0x1) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Ctlz(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x33:  
          // IntegerOperate::cttz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (!(temp<31:0>)) { temp >>= 32; count += 32; }\n                             if (!(temp<15:0>)) { temp >>= 16; count += 16; }\n                             if (!(temp<7:0>)) { temp >>= 8; count += 8; }\n                             if (!(temp<3:0>)) { temp >>= 4; count += 4; }\n                             if (!(temp<1:0>)) { temp >>= 2; count += 2; }\n                             if (!(temp<0:0> & ULL(0x1))) { \n                                 temp >>= 1; count += 1; \n                             }\n                             if (!(temp<0:0> & ULL(0x1))) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Cttz(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x34:  
          // IntegerOperate::unpkbw([' \n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<15:8> << 16)\n                                   | (Rb_uq<23:16> << 32)\n                                   | (Rb_uq<31:24> << 48));\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Unpkbw(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x35:  
          // IntegerOperate::unpkbl(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<15:8> << 32));\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Unpkbl(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x36:  
          // IntegerOperate::pkwb(['\n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<23:16> << 8)\n                                   | (Rb_uq<39:32> << 16)\n                                   | (Rb_uq<55:48> << 24));\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Pkwb(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x37:  
          // IntegerOperate::pklb(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<39:32> << 8));\n                           ', 'IntAluOp'],{})
          
           {
               AlphaStaticInst *i = new Pklb(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x38:  
          // IntegerOperate::minsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb < rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Minsb8(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x39:  
          // IntegerOperate::minsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Minsw4(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3a:  
          // IntegerOperate::minub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub < rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Minub8(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3b:  
          // IntegerOperate::minuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_sw = Ra_uq<hi:lo>;\n                                 uint16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Minuw4(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3c:  
          // IntegerOperate::maxub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub > rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Maxub8(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3d:  
          // IntegerOperate::maxuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_uw = Ra_uq<hi:lo>;\n                                 uint16_t rb_uw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_uw > rb_uw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Maxuw4(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3e:  
          // IntegerOperate::maxsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb > rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Maxsb8(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x3f:  
          // IntegerOperate::maxsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw > rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})
          
           {
               AlphaStaticInst *i = new Maxsw4(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x70:
          switch (RB) {
            
            case 0x1f:  
              // BasicOperateWithNopCheck::ftoit([' Rc = Fa_uq; ', 'FloatCvtOp'],{})
              
               {
                   AlphaStaticInst *i = new Ftoit(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x78:
          switch (RB) {
            
            case 0x1f:  
              // BasicOperateWithNopCheck::ftois([' Rc_sl = t_to_s(Fa_uq); ', 'FloatCvtOp'],{})
              
               {
                   AlphaStaticInst *i = new Ftois(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x39:  
      // CondBranch::beq([' cond = (Ra == 0); '],{})
      
          return new Beq(machInst);
      break;
    
    case 0x3d:  
      // CondBranch::bne([' cond = (Ra != 0); '],{})
      
          return new Bne(machInst);
      break;
    
    case 0x3e:  
      // CondBranch::bge([' cond = (Ra_sq >= 0); '],{})
      
          return new Bge(machInst);
      break;
    
    case 0x3f:  
      // CondBranch::bgt([' cond = (Ra_sq >  0); '],{})
      
          return new Bgt(machInst);
      break;
    
    case 0x3b:  
      // CondBranch::ble([' cond = (Ra_sq <= 0); '],{})
      
          return new Ble(machInst);
      break;
    
    case 0x3a:  
      // CondBranch::blt([' cond = (Ra_sq < 0); '],{})
      
          return new Blt(machInst);
      break;
    
    case 0x38:  
      // CondBranch::blbc([' cond = ((Ra & 1) == 0); '],{})
      
          return new Blbc(machInst);
      break;
    
    case 0x3c:  
      // CondBranch::blbs([' cond = ((Ra & 1) == 1); '],{})
      
          return new Blbs(machInst);
      break;
    
    case 0x31:  
      // CondBranch::fbeq([' cond = (Fa == 0); '],{})
      
          return new Fbeq(machInst);
      break;
    
    case 0x35:  
      // CondBranch::fbne([' cond = (Fa != 0); '],{})
      
          return new Fbne(machInst);
      break;
    
    case 0x36:  
      // CondBranch::fbge([' cond = (Fa >= 0); '],{})
      
          return new Fbge(machInst);
      break;
    
    case 0x37:  
      // CondBranch::fbgt([' cond = (Fa >  0); '],{})
      
          return new Fbgt(machInst);
      break;
    
    case 0x33:  
      // CondBranch::fble([' cond = (Fa <= 0); '],{})
      
          return new Fble(machInst);
      break;
    
    case 0x32:  
      // CondBranch::fblt([' cond = (Fa < 0); '],{})
      
          return new Fblt(machInst);
      break;
    
    case 0x30:  
      // UncondBranch::br([],{})
      
          return (RA == 31)
              ? (StaticInst *)new Br(machInst)
              : (StaticInst *)new BrAndLink(machInst);
      break;
    
    case 0x34:  
      // UncondBranch::bsr(['IsCall'],{})
      
          return (RA == 31)
              ? (StaticInst *)new Bsr(machInst)
              : (StaticInst *)new BsrAndLink(machInst);
      break;
    
    case 0x1a:
      switch (JMPFUNC) {
        
        case 0x0:  
          // Jump::jmp([],{})
          
              return (RA == 31)
                  ? (StaticInst *)new Jmp(machInst)
                  : (StaticInst *)new JmpAndLink(machInst);
          break;
        
        case 0x1:  
          // Jump::jsr(['IsCall'],{})
          
              return (RA == 31)
                  ? (StaticInst *)new Jsr(machInst)
                  : (StaticInst *)new JsrAndLink(machInst);
          break;
        
        case 0x2:  
          // Jump::ret(['IsReturn'],{})
          
              return (RA == 31)
                  ? (StaticInst *)new Ret(machInst)
                  : (StaticInst *)new RetAndLink(machInst);
          break;
        
        case 0x3:  
          // Jump::jsr_coroutine(['IsCall', 'IsReturn'],{})
          
              return (RA == 31)
                  ? (StaticInst *)new Jsr_coroutine(machInst)
                  : (StaticInst *)new Jsr_coroutineAndLink(machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x14:
      switch (FP_SHORTFUNC) {
        
        case 0x4:
          switch (RB) {
            
            case 0x1f:
              switch (FP_FULLFUNC) {
                
                case 0x4:  
                  // BasicOperateWithNopCheck::itofs([' Fc_uq = s_to_t(Ra_ul); ', 'FloatCvtOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Itofs(machInst);
                       if (RC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x24:  
                  // BasicOperateWithNopCheck::itoft([' Fc_uq = Ra_uq; ', 'FloatCvtOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Itoft(machInst);
                       if (RC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x14:  
                  // FailUnimpl::itoff(([], {}))
                  
                      return new FailUnimplemented("itoff", machInst);
                  break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0xb:
          switch (FA) {
            
            case 0x1f:
              switch (FP_TYPEFUNC) {
#if SS_COMPATIBLE_FP
                
                case 0xb:  
                  // FloatingPointOperate::sqrts(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Sqrts(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
#else
                
                case 0xb:  
                  // FloatingPointOperate::sqrts(['\n                        if (Fb_sf < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc_sf = sqrt(Fb_sf);\n                    ', 'FloatSqrtOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Sqrts(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
#endif
                
                case 0x2b:  
                  // FloatingPointOperate::sqrtt(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Sqrtt(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0xa:  
          // FailUnimpl::sqrtfg(([], {}))
          
              return new FailUnimplemented("sqrtfg", machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x16:
      switch (FP_SHORTFUNC_TOP2) {
        
        case 0x0:
          switch (FP_TRAPMODE) {
            
            case 0x0: case 0x1: case 0x5: case 0x7:
              switch (FP_TYPEFUNC) {
#if SS_COMPATIBLE_FP
                
                case 0x0:  
                  // FloatingPointOperate::adds([' Fc = Fa + Fb; '],{})
                  
                   {
                       AlphaStaticInst *i = new Adds(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x1:  
                  // FloatingPointOperate::subs([' Fc = Fa - Fb; '],{})
                  
                   {
                       AlphaStaticInst *i = new Subs(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x2:  
                  // FloatingPointOperate::muls([' Fc = Fa * Fb; ', 'FloatMultOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Muls(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x3:  
                  // FloatingPointOperate::divs([' Fc = Fa / Fb; ', 'FloatDivOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Divs(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
#else
                
                case 0x0:  
                  // FloatingPointOperate::adds([' Fc_sf = Fa_sf + Fb_sf; '],{})
                  
                   {
                       AlphaStaticInst *i = new Adds(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x1:  
                  // FloatingPointOperate::subs([' Fc_sf = Fa_sf - Fb_sf; '],{})
                  
                   {
                       AlphaStaticInst *i = new Subs(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x2:  
                  // FloatingPointOperate::muls([' Fc_sf = Fa_sf * Fb_sf; ', 'FloatMultOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Muls(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x3:  
                  // FloatingPointOperate::divs([' Fc_sf = Fa_sf / Fb_sf; ', 'FloatDivOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Divs(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
#endif
                
                case 0x20:  
                  // FloatingPointOperate::addt([' Fc = Fa + Fb; '],{})
                  
                   {
                       AlphaStaticInst *i = new Addt(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x21:  
                  // FloatingPointOperate::subt([' Fc = Fa - Fb; '],{})
                  
                   {
                       AlphaStaticInst *i = new Subt(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x22:  
                  // FloatingPointOperate::mult([' Fc = Fa * Fb; ', 'FloatMultOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Mult(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                case 0x23:  
                  // FloatingPointOperate::divt([' Fc = Fa / Fb; ', 'FloatDivOp'],{})
                  
                   {
                       AlphaStaticInst *i = new Divt(machInst);
                       if (FC == 31) {
                           i = makeNop(i);
                       }
                       return i;
                   }
                  break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x1:
          switch (FP_FULLFUNC) {
            
            case 0xa5: case 0x5a5:  
              // BasicOperateWithNopCheck::cmpteq([' Fc = (Fa == Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})
              
               {
                   AlphaStaticInst *i = new Cmpteq(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            case 0xa7: case 0x5a7:  
              // BasicOperateWithNopCheck::cmptle([' Fc = (Fa <= Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})
              
               {
                   AlphaStaticInst *i = new Cmptle(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            case 0xa6: case 0x5a6:  
              // BasicOperateWithNopCheck::cmptlt([' Fc = (Fa <  Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})
              
               {
                   AlphaStaticInst *i = new Cmptlt(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            case 0xa4: case 0x5a4:  
              // BasicOperateWithNopCheck::cmptun([' // unordered\n                    Fc = (!(Fa < Fb) && !(Fa == Fb) && !(Fa > Fb)) ? 2.0 : 0.0;\n                ', 'FloatCmpOp'],{})
              
               {
                   AlphaStaticInst *i = new Cmptun(machInst);
                   if (RC == 31) {
                       i = makeNop(i);
                   }
                   return i;
               }
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x3:
          switch (FA) {
            
            case 0x1f:
              switch (FP_TYPEFUNC) {
                
                case 0x2f:
                  switch (FP_ROUNDMODE) {
                    
                    case 0x0:  
                      // FPFixedRounding::cvttq([' Fc_sq = (int64_t)trunc(Fb); ', 'Chopped'],{})
                      
                       {
                           AlphaStaticInst *i = new CvttqChopped(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    case 0x1:  
                      // FPFixedRounding::cvttq([' Fc_sq = (int64_t)floor(Fb); ', 'MinusInfinity'],{})
                      
                       {
                           AlphaStaticInst *i = new CvttqMinusInfinity(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    default:  
                      // FloatingPointOperate::cvttq([' Fc_sq = (int64_t)nearbyint(Fb); '],{})
                      
                       {
                           AlphaStaticInst *i = new Cvttq(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    }
                  
                case 0x2c:
                  switch (FP_FULLFUNC) {
                    
                    case 0x2ac: case 0x6ac:  
                      // BasicOperateWithNopCheck::cvtst([' Fc = Fb_sf; '],{})
                      
                       {
                           AlphaStaticInst *i = new Cvtst(machInst);
                           if (RC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    default:  
                      // FloatingPointOperate::cvtts([' Fc_sf = Fb; '],{})
                      
                       {
                           AlphaStaticInst *i = new Cvtts(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    }
                  
                case 0x3c:
                  switch (FP_TRAPMODE) {
                    
                    case 0x0: case 0x7:  
                      // FloatingPointOperate::cvtqs([' Fc_sf = Fb_sq; '],{})
                      
                       {
                           AlphaStaticInst *i = new Cvtqs(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x3e:
                  switch (FP_TRAPMODE) {
                    
                    case 0x0: case 0x7:  
                      // FloatingPointOperate::cvtqt([' Fc    = Fb_sq; '],{})
                      
                       {
                           AlphaStaticInst *i = new Cvtqt(machInst);
                           if (FC == 31) {
                               i = makeNop(i);
                           }
                           return i;
                       }
                      break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x17:
      switch (FP_FULLFUNC) {
        
        case 0x10:  
          // BasicOperateWithNopCheck::cvtlq(['\n                Fc_sl = (Fb_uq<63:62> << 30) | Fb_uq<58:29>;\n            '],{})
          
           {
               AlphaStaticInst *i = new Cvtlq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x30:  
          // BasicOperateWithNopCheck::cvtql(['\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})
          
           {
               AlphaStaticInst *i = new Cvtql(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x130: case 0x530:  
          // BasicOperateWithNopCheck::cvtqlv(['\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = Fb_uq<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})
          
           {
               AlphaStaticInst *i = new Cvtqlv(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x20:  
          // BasicOperateWithNopCheck::cpys(['  // copy sign\n                Fc_uq = (Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})
          
           {
               AlphaStaticInst *i = new Cpys(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x21:  
          // BasicOperateWithNopCheck::cpysn([' // copy sign negated\n                Fc_uq = (~Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})
          
           {
               AlphaStaticInst *i = new Cpysn(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x22:  
          // BasicOperateWithNopCheck::cpyse([' // copy sign and exponent\n                Fc_uq = (Fa_uq<63:52> << 52) | Fb_uq<51:0>;\n            '],{})
          
           {
               AlphaStaticInst *i = new Cpyse(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2a:  
          // BasicOperateWithNopCheck::fcmoveq([' Fc = (Fa == 0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmoveq(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2b:  
          // BasicOperateWithNopCheck::fcmovne([' Fc = (Fa != 0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmovne(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2c:  
          // BasicOperateWithNopCheck::fcmovlt([' Fc = (Fa <  0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmovlt(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2d:  
          // BasicOperateWithNopCheck::fcmovge([' Fc = (Fa >= 0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmovge(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2e:  
          // BasicOperateWithNopCheck::fcmovle([' Fc = (Fa <= 0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmovle(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x2f:  
          // BasicOperateWithNopCheck::fcmovgt([' Fc = (Fa >  0) ? Fb : Fc; '],{})
          
           {
               AlphaStaticInst *i = new Fcmovgt(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x24:  
          // BasicOperateWithNopCheck::mt_fpcr([' FPCR = Fa_uq; ', 'IsIprAccess'],{})
          
           {
               AlphaStaticInst *i = new Mt_fpcr(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        case 0x25:  
          // BasicOperateWithNopCheck::mf_fpcr([' Fa_uq = FPCR; ', 'IsIprAccess'],{})
          
           {
               AlphaStaticInst *i = new Mf_fpcr(machInst);
               if (RC == 31) {
                   i = makeNop(i);
               }
               return i;
           }
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x18:
      switch (MEMFUNC) {
        
        case 0x8000:  
          // WarnUnimpl::fetch([],{})
          
              return new WarnUnimplemented("fetch", machInst);
          break;
        
        case 0xa000:  
          // WarnUnimpl::fetch_m([],{})
          
              return new WarnUnimplemented("fetch_m", machInst);
          break;
        
        case 0xe800:  
          // WarnUnimpl::ecb([],{})
          
              return new WarnUnimplemented("ecb", machInst);
          break;
        
        case 0xf800:  
          // MiscPrefetch::wh64([' EA = Rb & ~ULL(63); ', ' ; '],{'mem_flags': 'PREFETCH'})
          
              return new Wh64(machInst);
          break;
        
        case 0xc000:  
          // BasicOperate::rpcc(['\n                /* Rb is a fake dependency so here is a fun way to get\n                 * the parser to understand that.\n                 */\n                uint64_t unused_var M5_VAR_USED = Rb;\n                Ra = FullSystem ? xc->readMiscReg(IPR_CC) : curTick();\n            ', 'IsUnverifiable'],{})
          
              return new Rpcc(machInst);
          break;
        
        case 0x0:  
          // BasicOperate::trapb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})
          
              return new Trapb(machInst);
          break;
        
        case 0x400:  
          // BasicOperate::excb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})
          
              return new Excb(machInst);
          break;
        
        case 0x4000:  
          // BasicOperate::mb([' ', 'IsMemBarrier', 'MemReadOp'],{})
          
              return new Mb(machInst);
          break;
        
        case 0x4400:  
          // BasicOperate::wmb([' ', 'IsWriteBarrier', 'MemWriteOp'],{})
          
              return new Wmb(machInst);
          break;
        
        case 0xe000:
          switch (FullSystemInt) {
            
            case 0x0:  
              // FailUnimpl::rc_se(([], {}))
              
                  return new FailUnimplemented("rc_se", machInst);
              break;
            
            default:  
              // BasicOperate::rc((['\n                Ra = IntrFlag;\n                IntrFlag = 0;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))
              
                  return new Rc(machInst);
              break;
            }
          
        case 0xf000:
          switch (FullSystemInt) {
            
            case 0x0:  
              // FailUnimpl::rs_se(([], {}))
              
                  return new FailUnimplemented("rs_se", machInst);
              break;
            
            default:  
              // BasicOperate::rs((['\n                Ra = IntrFlag;\n                IntrFlag = 1;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))
              
                  return new Rs(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x0:
      switch (FullSystemInt) {
        
        case 0x0:
          switch (PALFUNC) {
            
            case 0x0:  
              // EmulatedCallPal::halt(['\n                    exitSimLoop("halt instruction encountered");\n                ', 'IsNonSpeculative'],{})
              
                  return new Halt(machInst);
              break;
            
            case 0x83:  
              // EmulatedCallPal::callsys(['\n                    xc->syscall(R0);\n                ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall'],{})
              
                  return new Callsys(machInst);
              break;
            
            case 0x9e:  
              // EmulatedCallPal::rduniq([' R0 = Runiq; ', 'IsIprAccess'],{})
              
                  return new Rduniq(machInst);
              break;
            
            case 0x9f:  
              // EmulatedCallPal::wruniq([' Runiq = R16; ', 'IsIprAccess'],{})
              
                  return new Wruniq(machInst);
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:  
          // CallPal::call_pal((['\n            if (!palValid ||\n                (palPriv\n                 && xc->readMiscReg(IPR_ICM) != mode_kernel)) {\n                // invalid pal function code, or attempt to do privileged\n                // PAL call in non-kernel mode\n                fault = new UnimplementedOpcodeFault;\n            } else {\n                // check to see if simulator wants to do something special\n                // on this PAL call (including maybe suppress it)\n                bool dopal = xc->simPalCheck(palFunc);\n\n                if (dopal) {\n                    xc->setMiscReg(IPR_EXC_ADDR, NPC);\n                    NPC = xc->readMiscReg(IPR_PAL_BASE) + palOffset;\n                }\n            }\n        ', 'IsNonSpeculative'], {}))
          
              return new Call_pal(machInst);
          break;
        }
      
    case 0x1b:
      switch (PALMODE) {
        
        case 0x0:  
          // OpcdecFault::hw_st_quad(([], {}))
          return new OpcdecFault(machInst);
          break;
        
        case 0x1:
          switch (HW_LDST_QUAD) {
            
            case 0x0:  
              // HwLoad::hw_ld([' EA = (Rb + disp) & ~3; ', ' Ra = Mem_ul; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})
              
                  return new Hw_ldL(machInst);
              break;
            
            case 0x1:  
              // HwLoad::hw_ld([' EA = (Rb + disp) & ~7; ', ' Ra = Mem_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})
              
                  return new Hw_ldQ(machInst);
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x1f:
      switch (PALMODE) {
        
        case 0x0:  
          // OpcdecFault::hw_st_cond(([], {}))
          return new OpcdecFault(machInst);
          break;
        
        case 0x1:
          switch (HW_LDST_COND) {
            
            case 0x0:
              switch (HW_LDST_QUAD) {
                
                case 0x0:  
                  // HwStore::hw_st([' EA = (Rb + disp) & ~3; ', ' Mem_ul = Ra<31:0>; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})
                  
                      return new Hw_stL(machInst);
                  break;
                
                case 0x1:  
                  // HwStore::hw_st([' EA = (Rb + disp) & ~7; ', ' Mem_uq = Ra_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})
                  
                      return new Hw_stQ(machInst);
                  break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x1:  
              // FailUnimpl::hw_st_cond(([], {}))
              
                  return new FailUnimplemented("hw_st_cond", machInst);
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x19:
      switch (PALMODE) {
        
        case 0x0:  
          // OpcdecFault::hw_mfpr(([], {}))
          return new OpcdecFault(machInst);
          break;
        
        case 0x1:  
          // HwMoveIPR::hw_mfpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsReadable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    Ra = xc->readMiscReg(miscRegIndex);\n            ', 'IsIprAccess'],{})
          
              return new Hw_mfpr(machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x1d:
      switch (PALMODE) {
        
        case 0x0:  
          // OpcdecFault::hw_mtpr(([], {}))
          return new OpcdecFault(machInst);
          break;
        
        case 0x1:  
          // HwMoveIPR::hw_mtpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsWritable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    xc->setMiscReg(miscRegIndex, Ra);\n                if (traceData) { traceData->setData(Ra); }\n            ', 'IsIprAccess'],{})
          
              return new Hw_mtpr(machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x1e:
      switch (PALMODE) {
        
        case 0x0:  
          // OpcdecFault::hw_rei(([], {}))
          return new OpcdecFault(machInst);
          break;
        
        case 0x1:  
          // BasicOperate::hw_rei([' xc->hwrei(); ', 'IsSerializing', 'IsSerializeBefore'],{})
          
              return new Hw_rei(machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    case 0x1:
      switch (M5FUNC) {
        
        case 0x0:  
          // BasicOperate::arm(['\n                PseudoInst::arm(xc->tcBase());\n            ', 'IsNonSpeculative'],{})
          
              return new Arm(machInst);
          break;
        
        case 0x1:  
          // BasicOperate::quiesce(["\n                // Don't sleep if (unmasked) interrupts are pending\n                Interrupts* interrupts =\n                    xc->tcBase()->getCpuPtr()->getInterruptController();\n                if (interrupts->checkInterrupts(xc->tcBase())) {\n                    PseudoInst::quiesceSkip(xc->tcBase());\n                } else {\n                    PseudoInst::quiesce(xc->tcBase());\n                }\n            ", 'IsNonSpeculative', 'IsQuiesce'],{})
          
              return new Quiesce(machInst);
          break;
        
        case 0x2:  
          // BasicOperate::quiesceNs(['\n                PseudoInst::quiesceNs(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce'],{})
          
              return new QuiesceNs(machInst);
          break;
        
        case 0x3:  
          // BasicOperate::quiesceCycles(['\n                PseudoInst::quiesceCycles(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce', 'IsUnverifiable'],{})
          
              return new QuiesceCycles(machInst);
          break;
        
        case 0x4:  
          // BasicOperate::quiesceTime(['\n                R0 = PseudoInst::quiesceTime(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})
          
              return new QuiesceTime(machInst);
          break;
        
        case 0x7:  
          // BasicOperate::rpns(['\n                R0 = PseudoInst::rpns(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})
          
              return new Rpns(machInst);
          break;
        
        case 0x9:  
          // BasicOperate::wakeCPU(['\n                PseudoInst::wakeCPU(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})
          
              return new WakeCPU(machInst);
          break;
        
        case 0x10:  
          // BasicOperate::deprecated_ivlb(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})
          
              return new Deprecated_ivlb(machInst);
          break;
        
        case 0x11:  
          // BasicOperate::deprecated_ivle(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})
          
              return new Deprecated_ivle(machInst);
          break;
        
        case 0x20:  
          // BasicOperate::deprecated_exit(['\n                warn_once("deprecated M5 exit instruction encountered.\\n");\n                PseudoInst::m5exit(xc->tcBase(), 0);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})
          
              return new Deprecated_exit(machInst);
          break;
        
        case 0x21:  
          // BasicOperate::m5exit(['\n                PseudoInst::m5exit(xc->tcBase(), R16);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})
          
              return new M5exit(machInst);
          break;
        
        case 0x31:  
          // BasicOperate::loadsymbol(['\n                PseudoInst::loadsymbol(xc->tcBase());\n            ', 'No_OpClass', 'IsNonSpeculative'],{})
          
              return new Loadsymbol(machInst);
          break;
        
        case 0x30:  
          // BasicOperate::initparam(['\n                Ra = PseudoInst::initParam(xc->tcBase());\n            '],{})
          
              return new Initparam(machInst);
          break;
        
        case 0x40:  
          // BasicOperate::resetstats(['\n                PseudoInst::resetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})
          
              return new Resetstats(machInst);
          break;
        
        case 0x41:  
          // BasicOperate::dumpstats(['\n                PseudoInst::dumpstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})
          
              return new Dumpstats(machInst);
          break;
        
        case 0x42:  
          // BasicOperate::dumpresetstats(['\n                PseudoInst::dumpresetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})
          
              return new Dumpresetstats(machInst);
          break;
        
        case 0x43:  
          // BasicOperate::m5checkpoint(['\n                PseudoInst::m5checkpoint(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})
          
              return new M5checkpoint(machInst);
          break;
        
        case 0x50:  
          // BasicOperate::m5readfile(['\n                R0 = PseudoInst::readfile(xc->tcBase(), R16, R17, R18);\n            ', 'IsNonSpeculative'],{})
          
              return new M5readfile(machInst);
          break;
        
        case 0x51:  
          // BasicOperate::m5break(['\n                PseudoInst::debugbreak(xc->tcBase());\n            ', 'IsNonSpeculative'],{})
          
              return new M5break(machInst);
          break;
        
        case 0x52:  
          // BasicOperate::m5switchcpu(['\n                PseudoInst::switchcpu(xc->tcBase());\n            ', 'IsNonSpeculative'],{})
          
              return new M5switchcpu(machInst);
          break;
        
        case 0x53:  
          // BasicOperate::m5addsymbol(['\n                PseudoInst::addsymbol(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})
          
              return new M5addsymbol(machInst);
          break;
        
        case 0x54:  
          // BasicOperate::m5panic(['\n                panic("M5 panic instruction called at pc = %#x.", PC);\n            ', 'IsNonSpeculative'],{})
          
              return new M5panic(machInst);
          break;
#define  CPANN(lbl) CPA::cpa()->lbl(xc->tcBase())
        
        case 0x55:
          switch (RA) {
            
            case 0x0:  
              // BasicOperate::m5a_old(['\n                    panic("Deprecated M5 annotate instruction executed "\n                          "at pc = %#x\\n", PC);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_old(machInst);
              break;
            
            case 0x1:  
              // BasicOperate::m5a_bsm(['\n                    CPANN(swSmBegin);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_bsm(machInst);
              break;
            
            case 0x2:  
              // BasicOperate::m5a_esm(['\n                    CPANN(swSmEnd);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_esm(machInst);
              break;
            
            case 0x3:  
              // BasicOperate::m5a_begin(['\n                    CPANN(swExplictBegin);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_begin(machInst);
              break;
            
            case 0x4:  
              // BasicOperate::m5a_end(['\n                    CPANN(swEnd);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_end(machInst);
              break;
            
            case 0x6:  
              // BasicOperate::m5a_q(['\n                    CPANN(swQ);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_q(machInst);
              break;
            
            case 0x7:  
              // BasicOperate::m5a_dq(['\n                    CPANN(swDq);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_dq(machInst);
              break;
            
            case 0x8:  
              // BasicOperate::m5a_wf(['\n                    CPANN(swWf);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_wf(machInst);
              break;
            
            case 0x9:  
              // BasicOperate::m5a_we(['\n                    CPANN(swWe);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_we(machInst);
              break;
            
            case 0xc:  
              // BasicOperate::m5a_sq(['\n                    CPANN(swSq);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_sq(machInst);
              break;
            
            case 0xd:  
              // BasicOperate::m5a_aq(['\n                    CPANN(swAq);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_aq(machInst);
              break;
            
            case 0xe:  
              // BasicOperate::m5a_pq(['\n                    CPANN(swPq);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_pq(machInst);
              break;
            
            case 0xf:  
              // BasicOperate::m5a_l(['\n                    CPANN(swLink);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_l(machInst);
              break;
            
            case 0x10:  
              // BasicOperate::m5a_identify(['\n                    CPANN(swIdentify);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_identify(machInst);
              break;
            
            case 0x11:  
              // BasicOperate::m5a_getid(['\n                    R0 = CPANN(swGetId);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_getid(machInst);
              break;
            
            case 0x13:  
              // BasicOperate::m5a_scl(['\n                    CPANN(swSyscallLink);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_scl(machInst);
              break;
            
            case 0x14:  
              // BasicOperate::m5a_rq(['\n                    CPANN(swRq);\n                ', 'IsNonSpeculative'],{})
              
                  return new M5a_rq(machInst);
              break;
            
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          #undef CPANN
        
        case 0x56:  
          // BasicOperate::m5reserved2(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})
          
              return new M5reserved2(machInst);
          break;
        
        case 0x57:  
          // BasicOperate::m5reserved3(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})
          
              return new M5reserved3(machInst);
          break;
        
        case 0x58:  
          // BasicOperate::m5reserved4(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})
          
              return new M5reserved4(machInst);
          break;
        
        case 0x59:  
          // BasicOperate::m5reserved5(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})
          
              return new M5reserved5(machInst);
          break;
        
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    default:
      
      // Unknown::unknown(([], {}))
      return new Unknown(machInst);
      break;
    }
  }
