
/*
 * DO NOT EDIT THIS FILE!!!
 *
 * It was automatically generated from the ISA description in alpha/isa/main.isa
 */

#include "base/bitfield.hh" // for bitfield support


#include <iomanip>
#include <iostream>
#include <sstream>

#include "arch/alpha/faults.hh"
#include "arch/alpha/types.hh"
#include "config/ss_compatible_fp.hh"
#include "cpu/static_inst.hh"
#include "mem/packet.hh"
#include "mem/request.hh"  // some constructors use MemReq flags


namespace AlphaISAInst {

#undef PALMODE
#define PALMODE	bits(machInst, 32, 32)
#undef OPCODE
#define OPCODE	bits(machInst, 31, 26)
#undef RA
#define RA	bits(machInst, 25, 21)
#undef RB
#define RB	bits(machInst, 20, 16)
#undef MEMDISP
#define MEMDISP	sext<16>(bits(machInst, 15,  0))
#undef MEMFUNC
#define MEMFUNC	bits(machInst, 15,  0)
#undef JMPFUNC
#define JMPFUNC	bits(machInst, 15, 14)
#undef JMPHINT
#define JMPHINT	bits(machInst, 13,  0)
#undef BRDISP
#define BRDISP	sext<21>(bits(machInst, 20,  0))
#undef INTIMM
#define INTIMM	bits(machInst, 20, 13)
#undef IMM
#define IMM	bits(machInst, 12, 12)
#undef INTFUNC
#define INTFUNC	bits(machInst, 11,  5)
#undef RC
#define RC	bits(machInst,  4,  0)
#undef FA
#define FA	bits(machInst, 25, 21)
#undef FB
#define FB	bits(machInst, 20, 16)
#undef FP_FULLFUNC
#define FP_FULLFUNC	bits(machInst, 15,  5)
#undef FP_TRAPMODE
#define FP_TRAPMODE	bits(machInst, 15, 13)
#undef FP_ROUNDMODE
#define FP_ROUNDMODE	bits(machInst, 12, 11)
#undef FP_TYPEFUNC
#define FP_TYPEFUNC	bits(machInst, 10,  5)
#undef FP_SRCTYPE
#define FP_SRCTYPE	bits(machInst, 10,  9)
#undef FP_SHORTFUNC
#define FP_SHORTFUNC	bits(machInst,  8,  5)
#undef FP_SHORTFUNC_TOP2
#define FP_SHORTFUNC_TOP2	bits(machInst,  8,  7)
#undef FC
#define FC	bits(machInst,  4,  0)
#undef PALFUNC
#define PALFUNC	bits(machInst, 25,  0)
#undef HW_LDST_PHYS
#define HW_LDST_PHYS	bits(machInst, 15, 15)
#undef HW_LDST_ALT
#define HW_LDST_ALT	bits(machInst, 14, 14)
#undef HW_LDST_WRTCK
#define HW_LDST_WRTCK	bits(machInst, 13, 13)
#undef HW_LDST_QUAD
#define HW_LDST_QUAD	bits(machInst, 12, 12)
#undef HW_LDST_VPTE
#define HW_LDST_VPTE	bits(machInst, 11, 11)
#undef HW_LDST_LOCK
#define HW_LDST_LOCK	bits(machInst, 10, 10)
#undef HW_LDST_COND
#define HW_LDST_COND	bits(machInst, 10, 10)
#undef HW_LDST_DISP
#define HW_LDST_DISP	sext<10>(bits(machInst,  9,  0))
#undef HW_REI_TYP
#define HW_REI_TYP	bits(machInst, 15, 14)
#undef HW_REI_MBZ
#define HW_REI_MBZ	bits(machInst, 13,  0)
#undef HW_IPR_IDX
#define HW_IPR_IDX	bits(machInst, 15,  0)
#undef M5FUNC
#define M5FUNC	bits(machInst,  7,  0)

// uncomment the following to get SimpleScalar-compatible disassembly
// (useful for diffing output traces).
// #define SS_COMPATIBLE_DISASSEMBLY

    /**
     * Base class for all Alpha static instructions.
     */
    class AlphaStaticInst : public StaticInst
    {
      protected:

        /// Make AlphaISA register dependence tags directly visible in
        /// this class and derived classes.  Maybe these should really
        /// live here and not in the AlphaISA namespace.
        enum DependenceTags {
            FP_Reg_Base = AlphaISA::FP_Reg_Base
        };

        /// Constructor.
        AlphaStaticInst(const char *mnem, ExtMachInst _machInst,
                        OpClass __opClass)
            : StaticInst(mnem, _machInst, __opClass)
        {
        }

        /// Print a register name for disassembly given the unique
        /// dependence tag number (FP or int).
        void printReg(std::ostream &os, int reg) const;

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;

        void
        advancePC(AlphaISA::PCState &pcState) const
        {
            pcState.advance();
        }
    };

    /**
     * Static instruction class for no-ops.  This is a leaf class.
     */
    class Nop : public AlphaStaticInst
    {
        /// Disassembly of original instruction.
        const std::string originalDisassembly;

      public:
        /// Constructor
        Nop(const std::string _originalDisassembly, ExtMachInst _machInst)
            : AlphaStaticInst("nop", _machInst, No_OpClass),
              originalDisassembly(_originalDisassembly)
        {
            flags[IsNop] = true;
        }

        ~Nop() { }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /// Helper function for decoding nops.  Substitute Nop object
    /// for original inst passed in as arg (and delete latter).
    static inline
    AlphaStaticInst *
    makeNop(AlphaStaticInst *inst)
    {
        AlphaStaticInst *nop = new Nop(inst->disassemble(0), inst->machInst);
        delete inst;
        return nop;
    }

    /**
     * Base class for integer immediate instructions.
     */
    class IntegerImm : public AlphaStaticInst
    {
      protected:
        /// Immediate operand value (unsigned 8-bit int).
        uint8_t imm;

        /// Constructor
        IntegerImm(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass), imm(INTIMM)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for general floating-point instructions.  Includes
     * support for various Alpha rounding and trapping modes.  Only FP
     * instructions that require this support are derived from this
     * class; the rest derive directly from AlphaStaticInst.
     */
    class AlphaFP : public AlphaStaticInst
    {
      public:
        /// Alpha FP rounding modes.
        enum RoundingMode {
            Chopped = 0,        ///< round toward zero
            Minus_Infinity = 1, ///< round toward minus infinity
            Normal = 2,         ///< round to nearest (default)
            Dynamic = 3,        ///< use FPCR setting (in instruction)
            Plus_Infinity = 3   ///< round to plus inifinity (in FPCR)
        };

        /// Alpha FP trapping modes.
        /// For instructions that produce integer results, the
        /// "Underflow Enable" modes really mean "Overflow Enable", and
        /// the assembly modifier is V rather than U.
        enum TrappingMode {
            /// default: nothing enabled
            Imprecise = 0,                 ///< no modifier
            /// underflow/overflow traps enabled, inexact disabled
            Underflow_Imprecise = 1,       ///< /U or /V
            Underflow_Precise = 5,         ///< /SU or /SV
            /// underflow/overflow and inexact traps enabled
            Underflow_Inexact_Precise = 7  ///< /SUI or /SVI
        };

      protected:
        /// Map Alpha rounding mode to C99 constants from <fenv.h>.
        static const int alphaToC99RoundingMode[];

        /// Map enum RoundingMode values to disassembly suffixes.
        static const char *roundingModeSuffix[];
        /// Map enum TrappingMode values to FP disassembly suffixes.
        static const char *fpTrappingModeSuffix[];
        /// Map enum TrappingMode values to integer disassembly suffixes.
        static const char *intTrappingModeSuffix[];

        /// This instruction's rounding mode.
        RoundingMode roundingMode;
        /// This instruction's trapping mode.
        TrappingMode trappingMode;

        /// Have we warned about this instruction's unsupported
        /// rounding mode (if applicable)?
        mutable bool warnedOnRounding;

        /// Have we warned about this instruction's unsupported
        /// trapping mode (if applicable)?
        mutable bool warnedOnTrapping;

        /// Constructor
        AlphaFP(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass),
              roundingMode((enum RoundingMode)FP_ROUNDMODE),
              trappingMode((enum TrappingMode)FP_TRAPMODE),
              warnedOnRounding(false),
              warnedOnTrapping(false)
        {
        }

        int getC99RoundingMode(uint64_t fpcr_val) const;

        // This differs from the AlphaStaticInst version only in
        // printing suffixes for non-default rounding & trapping modes.
        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };


    /**
     * Base class for general Alpha memory-format instructions.
     */
    class Memory : public AlphaStaticInst
    {
      protected:

        /// Memory request flags.  See mem_req_base.hh.
        Request::Flags memAccessFlags;

        /// Constructor
        Memory(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for memory-format instructions using a 32-bit
     * displacement (i.e. most of them).
     */
    class MemoryDisp32 : public Memory
    {
      protected:
        /// Displacement for EA calculation (signed).
        int32_t disp;

        /// Constructor.
        MemoryDisp32(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : Memory(mnem, _machInst, __opClass),
              disp(MEMDISP)
        {
        }
    };


    /**
     * Base class for a few miscellaneous memory-format insts
     * that don't interpret the disp field: wh64, fetch, fetch_m, ecb.
     * None of these instructions has a destination register either.
     */
    class MemoryNoDisp : public Memory
    {
      protected:
        /// Constructor
        MemoryNoDisp(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : Memory(mnem, _machInst, __opClass)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };


    /**
     * Base class for instructions whose disassembly is not purely a
     * function of the machine instruction (i.e., it depends on the
     * PC).  This class overrides the disassemble() method to check
     * the PC and symbol table values before re-using a cached
     * disassembly string.  This is necessary for branches and jumps,
     * where the disassembly string includes the target address (which
     * may depend on the PC and/or symbol table).
     */
    class PCDependentDisassembly : public AlphaStaticInst
    {
      protected:
        /// Cached program counter from last disassembly
        mutable Addr cachedPC;
        /// Cached symbol table pointer from last disassembly
        mutable const SymbolTable *cachedSymtab;

        /// Constructor
        PCDependentDisassembly(const char *mnem, ExtMachInst _machInst,
                               OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass),
              cachedPC(0), cachedSymtab(0)
        {
        }

        const std::string &
        disassemble(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for branches (PC-relative control transfers),
     * conditional or unconditional.
     */
    class Branch : public PCDependentDisassembly
    {
      protected:
        /// Displacement to target address (signed).
        int32_t disp;

        /// Constructor.
        Branch(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : PCDependentDisassembly(mnem, _machInst, __opClass),
              disp(BRDISP << 2)
        {
        }

        AlphaISA::PCState branchTarget(const AlphaISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for jumps (register-indirect control transfers).  In
     * the Alpha ISA, these are always unconditional.
     */
    class Jump : public PCDependentDisassembly
    {
      protected:

        /// Displacement to target address (signed).
        int32_t disp;

      public:
        /// Constructor
        Jump(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : PCDependentDisassembly(mnem, _machInst, __opClass),
              disp(BRDISP)
        {
        }

        AlphaISA::PCState branchTarget(ThreadContext *tc) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for emulated call_pal calls (used only in
     * non-full-system mode).
     */
    class EmulatedCallPal : public AlphaStaticInst
    {
      protected:

        /// Constructor.
        EmulatedCallPal(const char *mnem, ExtMachInst _machInst,
                        OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for full-system-mode call_pal instructions.
     * Probably could turn this into a leaf class and get rid of the
     * parser template.
     */
    class CallPalBase : public AlphaStaticInst
    {
      protected:
        int palFunc;    ///< Function code part of instruction
        int palOffset;  ///< Target PC, offset from IPR_PAL_BASE
        bool palValid;  ///< is the function code valid?
        bool palPriv;   ///< is this call privileged?

        /// Constructor.
        CallPalBase(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass);

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for hw_ld and hw_st.
     */
    class HwLoadStore : public Memory
    {
      protected:

        /// Displacement for EA calculation (signed).
        int16_t disp;

        /// Constructor
        HwLoadStore(const char *mnem, ExtMachInst _machInst, OpClass __opClass);

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for hw_mfpr and hw_mtpr.
     */
    class HwMoveIPR : public AlphaStaticInst
    {
      protected:
        /// Index of internal processor register.
        int ipr_index;

        /// Constructor
        HwMoveIPR(const char *mnem, ExtMachInst _machInst, OpClass __opClass)
            : AlphaStaticInst(mnem, _machInst, __opClass),
              ipr_index(HW_IPR_IDX)
        {
        }

        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Static instruction class for instructions that cause an OPCDEC fault
     * when executed.  This is currently only for PAL mode instructions
     * executed in non-PAL mode.
     */
    class OpcdecFault : public AlphaStaticInst
    {
      public:
        /// Constructor
        OpcdecFault(ExtMachInst _machInst)
            : AlphaStaticInst("opcdec fault", _machInst, No_OpClass)
        {
        }

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Static instruction class for unimplemented instructions that
     * cause simulator termination.  Note that these are recognized
     * (legal) instructions that the simulator does not support; the
     * 'Unknown' class is used for unrecognized/illegal instructions.
     * This is a leaf class.
     */
    class FailUnimplemented : public AlphaStaticInst
    {
      public:
        /// Constructor
        FailUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : AlphaStaticInst(_mnemonic, _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for unimplemented instructions that cause a warning
     * to be printed (but do not terminate simulation).  This
     * implementation is a little screwy in that it will print a
     * warning for each instance of a particular unimplemented machine
     * instruction, not just for each unimplemented opcode.  Should
     * probably make the 'warned' flag a static member of the derived
     * class.
     */
    class WarnUnimplemented : public AlphaStaticInst
    {
      private:
        /// Have we warned on this instruction yet?
        mutable bool warned;

      public:
        /// Constructor
        WarnUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : AlphaStaticInst(_mnemonic, _machInst, No_OpClass), warned(false)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Static instruction class for unknown (illegal) instructions.
     * These cause simulator termination if they are executed in a
     * non-speculative mode.  This is a leaf class.
     */
    class Unknown : public AlphaStaticInst
    {
      public:
        /// Constructor
        Unknown(ExtMachInst _machInst)
            : AlphaStaticInst("unknown", _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

// LoadAddress::lda([' Ra = Rb + disp; '],{})

    /**
     * Static instruction class for "lda".
     */
    class Lda : public MemoryDisp32
    {
      public:
        /// Constructor.
        Lda(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// LoadAddress::ldah([' Ra = Rb + (disp << 16); '],{})

    /**
     * Static instruction class for "ldah".
     */
    class Ldah : public MemoryDisp32
    {
      public:
        /// Constructor.
        Ldah(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// LoadOrNop::ldbu([' Ra_uq = Mem_ub; '],{})

    /**
     * Static instruction class for "ldbu".
     */
    class Ldbu : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldbu(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrNop::ldwu([' Ra_uq = Mem_uw; '],{})

    /**
     * Static instruction class for "ldwu".
     */
    class Ldwu : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldwu(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrNop::ldq_u([' Ra = Mem_uq; '],{'ea_code': ' EA = (Rb + disp) & ~7; '})

    /**
     * Static instruction class for "ldq_u".
     */
    class Ldq_u : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldq_u(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrNop::ldt([' Fa = Mem_df; '],{})

    /**
     * Static instruction class for "ldt".
     */
    class Ldt : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrNop::ldl_l([' Ra_sl = Mem_sl; '],{'mem_flags': 'LLSC'})

    /**
     * Static instruction class for "ldl_l".
     */
    class Ldl_l : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldl_l(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrNop::ldq_l([' Ra_uq = Mem_uq; '],{'mem_flags': 'LLSC'})

    /**
     * Static instruction class for "ldq_l".
     */
    class Ldq_l : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldq_l(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrPrefetch::ldl([' Ra_sl = Mem_sl; '],{})

    /**
     * Static instruction class for "ldl".
     */
    class Ldl : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldl".
     */
    class LdlPrefetch : public MemoryDisp32
    {
      public:

        /// Constructor.
        LdlPrefetch(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrPrefetch::ldq([' Ra_uq = Mem_uq; '],{'pf_flags': 'EVICT_NEXT'})

    /**
     * Static instruction class for "ldq".
     */
    class Ldq : public MemoryDisp32
    {
      public:

        /// Constructor.
        Ldq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldq".
     */
    class LdqPrefetch : public MemoryDisp32
    {
      public:

        /// Constructor.
        LdqPrefetch(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// LoadOrPrefetch::lds([' Fa_uq = s_to_t(Mem_ul); '],{'pf_flags': 'PF_EXCLUSIVE', 'inst_flags': 'IsFloating'})

    /**
     * Static instruction class for "lds".
     */
    class Lds : public MemoryDisp32
    {
      public:

        /// Constructor.
        Lds(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "lds".
     */
    class LdsPrefetch : public MemoryDisp32
    {
      public:

        /// Constructor.
        LdsPrefetch(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stb([' Mem_ub = Ra<7:0>; '],{})

    /**
     * Static instruction class for "stb".
     */
    class Stb : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stw([' Mem_uw = Ra<15:0>; '],{})

    /**
     * Static instruction class for "stw".
     */
    class Stw : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stw(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stl([' Mem_ul = Ra<31:0>; '],{})

    /**
     * Static instruction class for "stl".
     */
    class Stl : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stq([' Mem_uq = Ra_uq; '],{})

    /**
     * Static instruction class for "stq".
     */
    class Stq : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stq_u([' Mem_uq = Ra_uq; ', ' EA = (Rb + disp) & ~7; '],{})

    /**
     * Static instruction class for "stq_u".
     */
    class Stq_u : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stq_u(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::sts([' Mem_ul = t_to_s(Fa_uq); '],{})

    /**
     * Static instruction class for "sts".
     */
    class Sts : public MemoryDisp32
    {
      public:

        /// Constructor.
        Sts(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Store::stt([' Mem_df = Fa; '],{})

    /**
     * Static instruction class for "stt".
     */
    class Stt : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// StoreCond::stl_c([' Mem_ul = Ra<31:0>; ', '\n                        uint64_t tmp = write_result;\n                        // see stq_c\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            xc->setStCondFailures(0);\n                        }\n                    '],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    /**
     * Static instruction class for "stl_c".
     */
    class Stl_c : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stl_c(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// StoreCond::stq_c([' Mem_uq = Ra; ', "\n                        uint64_t tmp = write_result;\n                        // If the write operation returns 0 or 1, then\n                        // this was a conventional store conditional,\n                        // and the value indicates the success/failure\n                        // of the operation.  If another value is\n                        // returned, then this was a Turbolaser\n                        // mailbox access, and we don't update the\n                        // result register at all.\n                        Ra = (tmp == 0 || tmp == 1) ? tmp : Ra;\n                        if (tmp == 1) {\n                            // clear failure counter... this is\n                            // non-architectural and for debugging\n                            // only.\n                            xc->setStCondFailures(0);\n                        }\n                    "],{'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'})

    /**
     * Static instruction class for "stq_c".
     */
    class Stq_c : public MemoryDisp32
    {
      public:

        /// Constructor.
        Stq_c(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// IntegerOperate::addl([' Rc_sl = Ra_sl + Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "addl".
     */
    class Addl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Addl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "addl".
     */
    class AddlImm : public IntegerImm
    {
      public:
        /// Constructor.
        AddlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::addlv(['\n                int32_t tmp  = Ra_sl + Rb_or_imm_sl;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra_sl<31:> == Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    /**
     * Static instruction class for "addlv".
     */
    class Addlv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Addlv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "addlv".
     */
    class AddlvImm : public IntegerImm
    {
      public:
        /// Constructor.
        AddlvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s4addl([' Rc_sl = (Ra_sl << 2) + Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "s4addl".
     */
    class S4addl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S4addl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s4addl".
     */
    class S4addlImm : public IntegerImm
    {
      public:
        /// Constructor.
        S4addlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s8addl([' Rc_sl = (Ra_sl << 3) + Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "s8addl".
     */
    class S8addl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S8addl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s8addl".
     */
    class S8addlImm : public IntegerImm
    {
      public:
        /// Constructor.
        S8addlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::addq([' Rc = Ra + Rb_or_imm; '],{})

    /**
     * Static instruction class for "addq".
     */
    class Addq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Addq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "addq".
     */
    class AddqImm : public IntegerImm
    {
      public:
        /// Constructor.
        AddqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::addqv(['\n                uint64_t tmp = Ra + Rb_or_imm;\n                // signed overflow occurs when operands have same sign\n                // and sign of result does not match.\n                if (Ra<63:> == Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    /**
     * Static instruction class for "addqv".
     */
    class Addqv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Addqv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "addqv".
     */
    class AddqvImm : public IntegerImm
    {
      public:
        /// Constructor.
        AddqvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s4addq([' Rc = (Ra << 2) + Rb_or_imm; '],{})

    /**
     * Static instruction class for "s4addq".
     */
    class S4addq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S4addq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s4addq".
     */
    class S4addqImm : public IntegerImm
    {
      public:
        /// Constructor.
        S4addqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s8addq([' Rc = (Ra << 3) + Rb_or_imm; '],{})

    /**
     * Static instruction class for "s8addq".
     */
    class S8addq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S8addq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s8addq".
     */
    class S8addqImm : public IntegerImm
    {
      public:
        /// Constructor.
        S8addqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::subl([' Rc_sl = Ra_sl - Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "subl".
     */
    class Subl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Subl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "subl".
     */
    class SublImm : public IntegerImm
    {
      public:
        /// Constructor.
        SublImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::sublv(['\n                int32_t tmp  = Ra_sl - Rb_or_imm_sl;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra_sl<31:> != Rb_or_imm_sl<31:> && tmp<31:> != Ra_sl<31:>)\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp;\n            '],{})

    /**
     * Static instruction class for "sublv".
     */
    class Sublv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Sublv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "sublv".
     */
    class SublvImm : public IntegerImm
    {
      public:
        /// Constructor.
        SublvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s4subl([' Rc_sl = (Ra_sl << 2) - Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "s4subl".
     */
    class S4subl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S4subl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s4subl".
     */
    class S4sublImm : public IntegerImm
    {
      public:
        /// Constructor.
        S4sublImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s8subl([' Rc_sl = (Ra_sl << 3) - Rb_or_imm_sl; '],{})

    /**
     * Static instruction class for "s8subl".
     */
    class S8subl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S8subl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s8subl".
     */
    class S8sublImm : public IntegerImm
    {
      public:
        /// Constructor.
        S8sublImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::subq([' Rc = Ra - Rb_or_imm; '],{})

    /**
     * Static instruction class for "subq".
     */
    class Subq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Subq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "subq".
     */
    class SubqImm : public IntegerImm
    {
      public:
        /// Constructor.
        SubqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::subqv(['\n                uint64_t tmp  = Ra - Rb_or_imm;\n                // signed overflow detection is same as for add,\n                // except we need to look at the *complemented*\n                // sign bit of the subtrahend (Rb), i.e., if the initial\n                // signs are the *same* then no overflow can occur\n                if (Ra<63:> != Rb_or_imm<63:> && tmp<63:> != Ra<63:>)\n                    fault = new IntegerOverflowFault;\n                Rc = tmp;\n            '],{})

    /**
     * Static instruction class for "subqv".
     */
    class Subqv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Subqv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "subqv".
     */
    class SubqvImm : public IntegerImm
    {
      public:
        /// Constructor.
        SubqvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s4subq([' Rc = (Ra << 2) - Rb_or_imm; '],{})

    /**
     * Static instruction class for "s4subq".
     */
    class S4subq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S4subq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s4subq".
     */
    class S4subqImm : public IntegerImm
    {
      public:
        /// Constructor.
        S4subqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::s8subq([' Rc = (Ra << 3) - Rb_or_imm; '],{})

    /**
     * Static instruction class for "s8subq".
     */
    class S8subq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        S8subq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "s8subq".
     */
    class S8subqImm : public IntegerImm
    {
      public:
        /// Constructor.
        S8subqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmpeq([' Rc = (Ra == Rb_or_imm); '],{})

    /**
     * Static instruction class for "cmpeq".
     */
    class Cmpeq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmpeq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmpeq".
     */
    class CmpeqImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpeqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmple([' Rc = (Ra_sq <= Rb_or_imm_sq); '],{})

    /**
     * Static instruction class for "cmple".
     */
    class Cmple : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmple(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmple".
     */
    class CmpleImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpleImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmplt([' Rc = (Ra_sq <  Rb_or_imm_sq); '],{})

    /**
     * Static instruction class for "cmplt".
     */
    class Cmplt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmplt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmplt".
     */
    class CmpltImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpltImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmpule([' Rc = (Ra_uq <= Rb_or_imm_uq); '],{})

    /**
     * Static instruction class for "cmpule".
     */
    class Cmpule : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmpule(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmpule".
     */
    class CmpuleImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpuleImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmpult([' Rc = (Ra_uq <  Rb_or_imm_uq); '],{})

    /**
     * Static instruction class for "cmpult".
     */
    class Cmpult : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmpult(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmpult".
     */
    class CmpultImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpultImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmpbge(['\n                int hi = 7;\n                int lo = 0;\n                uint64_t tmp = 0;\n                for (int i = 0; i < 8; ++i) {\n                    tmp |= (Ra_uq<hi:lo> >= Rb_or_imm_uq<hi:lo>) << i;\n                    hi += 8;\n                    lo += 8;\n                }\n                Rc = tmp;\n            '],{})

    /**
     * Static instruction class for "cmpbge".
     */
    class Cmpbge : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmpbge(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmpbge".
     */
    class CmpbgeImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmpbgeImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::and([' Rc = Ra & Rb_or_imm; '],{})

    /**
     * Static instruction class for "and".
     */
    class And : public AlphaStaticInst
    {
      public:
        /// Constructor.
        And(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "and".
     */
    class AndImm : public IntegerImm
    {
      public:
        /// Constructor.
        AndImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::bic([' Rc = Ra & ~Rb_or_imm; '],{})

    /**
     * Static instruction class for "bic".
     */
    class Bic : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Bic(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "bic".
     */
    class BicImm : public IntegerImm
    {
      public:
        /// Constructor.
        BicImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::bis([' Rc = Ra | Rb_or_imm; '],{})

    /**
     * Static instruction class for "bis".
     */
    class Bis : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Bis(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "bis".
     */
    class BisImm : public IntegerImm
    {
      public:
        /// Constructor.
        BisImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::ornot([' Rc = Ra | ~Rb_or_imm; '],{})

    /**
     * Static instruction class for "ornot".
     */
    class Ornot : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Ornot(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ornot".
     */
    class OrnotImm : public IntegerImm
    {
      public:
        /// Constructor.
        OrnotImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::xor([' Rc = Ra ^ Rb_or_imm; '],{})

    /**
     * Static instruction class for "xor".
     */
    class Xor : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Xor(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "xor".
     */
    class XorImm : public IntegerImm
    {
      public:
        /// Constructor.
        XorImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::eqv([' Rc = Ra ^ ~Rb_or_imm; '],{})

    /**
     * Static instruction class for "eqv".
     */
    class Eqv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Eqv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "eqv".
     */
    class EqvImm : public IntegerImm
    {
      public:
        /// Constructor.
        EqvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovlbs([' Rc = ((Ra & 1) == 1) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovlbs".
     */
    class Cmovlbs : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovlbs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovlbs".
     */
    class CmovlbsImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovlbsImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovlbc([' Rc = ((Ra & 1) == 0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovlbc".
     */
    class Cmovlbc : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovlbc(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovlbc".
     */
    class CmovlbcImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovlbcImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmoveq([' Rc = (Ra == 0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmoveq".
     */
    class Cmoveq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmoveq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmoveq".
     */
    class CmoveqImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmoveqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovne([' Rc = (Ra != 0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovne".
     */
    class Cmovne : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovne(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovne".
     */
    class CmovneImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovneImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovlt([' Rc = (Ra_sq <  0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovlt".
     */
    class Cmovlt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovlt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovlt".
     */
    class CmovltImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovltImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovge([' Rc = (Ra_sq >= 0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovge".
     */
    class Cmovge : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovge(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovge".
     */
    class CmovgeImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovgeImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovle([' Rc = (Ra_sq <= 0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovle".
     */
    class Cmovle : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovle(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovle".
     */
    class CmovleImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovleImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cmovgt([' Rc = (Ra_sq >  0) ? Rb_or_imm : Rc; '],{})

    /**
     * Static instruction class for "cmovgt".
     */
    class Cmovgt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmovgt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "cmovgt".
     */
    class CmovgtImm : public IntegerImm
    {
      public:
        /// Constructor.
        CmovgtImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::amask([' Rc = Rb_or_imm & ~ULL(0x17); '],{})

    /**
     * Static instruction class for "amask".
     */
    class Amask : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Amask(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "amask".
     */
    class AmaskImm : public IntegerImm
    {
      public:
        /// Constructor.
        AmaskImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::implver([' Rc = FullSystem ? 1 : 2 '],{})

    /**
     * Static instruction class for "implver".
     */
    class Implver : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Implver(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// WarnUnimpl::eleven25(([], {}))

// Unknown::unknown(([], {}))

// IntegerOperate::sll([' Rc = Ra << Rb_or_imm<5:0>; '],{})

    /**
     * Static instruction class for "sll".
     */
    class Sll : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Sll(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "sll".
     */
    class SllImm : public IntegerImm
    {
      public:
        /// Constructor.
        SllImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::srl([' Rc = Ra_uq >> Rb_or_imm<5:0>; '],{})

    /**
     * Static instruction class for "srl".
     */
    class Srl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Srl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srl".
     */
    class SrlImm : public IntegerImm
    {
      public:
        /// Constructor.
        SrlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::sra([' Rc = Ra_sq >> Rb_or_imm<5:0>; '],{})

    /**
     * Static instruction class for "sra".
     */
    class Sra : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Sra(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "sra".
     */
    class SraImm : public IntegerImm
    {
      public:
        /// Constructor.
        SraImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskbl([' Rc = Ra & ~(mask( 8) << (Rb_or_imm<2:0> * 8)); '],{})

    /**
     * Static instruction class for "mskbl".
     */
    class Mskbl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskbl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskbl".
     */
    class MskblImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskblImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskwl([' Rc = Ra & ~(mask(16) << (Rb_or_imm<2:0> * 8)); '],{})

    /**
     * Static instruction class for "mskwl".
     */
    class Mskwl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskwl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskwl".
     */
    class MskwlImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskwlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskll([' Rc = Ra & ~(mask(32) << (Rb_or_imm<2:0> * 8)); '],{})

    /**
     * Static instruction class for "mskll".
     */
    class Mskll : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskll(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskll".
     */
    class MskllImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskllImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskql([' Rc = Ra & ~(mask(64) << (Rb_or_imm<2:0> * 8)); '],{})

    /**
     * Static instruction class for "mskql".
     */
    class Mskql : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskql(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskql".
     */
    class MskqlImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskqlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskwh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(16) >> (64 - 8 * bv))) : Ra;\n            '],{})

    /**
     * Static instruction class for "mskwh".
     */
    class Mskwh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskwh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskwh".
     */
    class MskwhImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskwhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::msklh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(32) >> (64 - 8 * bv))) : Ra;\n            '],{})

    /**
     * Static instruction class for "msklh".
     */
    class Msklh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Msklh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "msklh".
     */
    class MsklhImm : public IntegerImm
    {
      public:
        /// Constructor.
        MsklhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mskqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc =  bv ? (Ra & ~(mask(64) >> (64 - 8 * bv))) : Ra;\n            '],{})

    /**
     * Static instruction class for "mskqh".
     */
    class Mskqh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mskqh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mskqh".
     */
    class MskqhImm : public IntegerImm
    {
      public:
        /// Constructor.
        MskqhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extbl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))< 7:0>; '],{})

    /**
     * Static instruction class for "extbl".
     */
    class Extbl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extbl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extbl".
     */
    class ExtblImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtblImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extwl([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<15:0>; '],{})

    /**
     * Static instruction class for "extwl".
     */
    class Extwl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extwl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extwl".
     */
    class ExtwlImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtwlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extll([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8))<31:0>; '],{})

    /**
     * Static instruction class for "extll".
     */
    class Extll : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extll(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extll".
     */
    class ExtllImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtllImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extql([' Rc = (Ra_uq >> (Rb_or_imm<2:0> * 8)); '],{})

    /**
     * Static instruction class for "extql".
     */
    class Extql : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extql(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extql".
     */
    class ExtqlImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtqlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extwh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<15:0>; '],{})

    /**
     * Static instruction class for "extwh".
     */
    class Extwh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extwh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extwh".
     */
    class ExtwhImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtwhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extlh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>)<31:0>; '],{})

    /**
     * Static instruction class for "extlh".
     */
    class Extlh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extlh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extlh".
     */
    class ExtlhImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtlhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::extqh(['\n                Rc = (Ra << (64 - (Rb_or_imm<2:0> * 8))<5:0>); '],{})

    /**
     * Static instruction class for "extqh".
     */
    class Extqh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Extqh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "extqh".
     */
    class ExtqhImm : public IntegerImm
    {
      public:
        /// Constructor.
        ExtqhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::insbl([' Rc = Ra< 7:0> << (Rb_or_imm<2:0> * 8); '],{})

    /**
     * Static instruction class for "insbl".
     */
    class Insbl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Insbl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "insbl".
     */
    class InsblImm : public IntegerImm
    {
      public:
        /// Constructor.
        InsblImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::inswl([' Rc = Ra<15:0> << (Rb_or_imm<2:0> * 8); '],{})

    /**
     * Static instruction class for "inswl".
     */
    class Inswl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Inswl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "inswl".
     */
    class InswlImm : public IntegerImm
    {
      public:
        /// Constructor.
        InswlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::insll([' Rc = Ra<31:0> << (Rb_or_imm<2:0> * 8); '],{})

    /**
     * Static instruction class for "insll".
     */
    class Insll : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Insll(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "insll".
     */
    class InsllImm : public IntegerImm
    {
      public:
        /// Constructor.
        InsllImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::insql([' Rc = Ra       << (Rb_or_imm<2:0> * 8); '],{})

    /**
     * Static instruction class for "insql".
     */
    class Insql : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Insql(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "insql".
     */
    class InsqlImm : public IntegerImm
    {
      public:
        /// Constructor.
        InsqlImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::inswh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<15:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    /**
     * Static instruction class for "inswh".
     */
    class Inswh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Inswh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "inswh".
     */
    class InswhImm : public IntegerImm
    {
      public:
        /// Constructor.
        InswhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::inslh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq<31:0> >> (64 - 8 * bv)) : 0;\n            '],{})

    /**
     * Static instruction class for "inslh".
     */
    class Inslh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Inslh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "inslh".
     */
    class InslhImm : public IntegerImm
    {
      public:
        /// Constructor.
        InslhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::insqh(['\n                int bv = Rb_or_imm<2:0>;\n                Rc = bv ? (Ra_uq       >> (64 - 8 * bv)) : 0;\n            '],{})

    /**
     * Static instruction class for "insqh".
     */
    class Insqh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Insqh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "insqh".
     */
    class InsqhImm : public IntegerImm
    {
      public:
        /// Constructor.
        InsqhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::zap(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    /**
     * Static instruction class for "zap".
     */
    class Zap : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Zap(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "zap".
     */
    class ZapImm : public IntegerImm
    {
      public:
        /// Constructor.
        ZapImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::zapnot(['\n                uint64_t zapmask = 0;\n                for (int i = 0; i < 8; ++i) {\n                    if (!Rb_or_imm<i:>)\n                        zapmask |= (mask(8) << (i * 8));\n                }\n                Rc = Ra & ~zapmask;\n            '],{})

    /**
     * Static instruction class for "zapnot".
     */
    class Zapnot : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Zapnot(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "zapnot".
     */
    class ZapnotImm : public IntegerImm
    {
      public:
        /// Constructor.
        ZapnotImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::mull([' Rc_sl = Ra_sl * Rb_or_imm_sl; ', 'IntMultOp'],{})

    /**
     * Static instruction class for "mull".
     */
    class Mull : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mull(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mull".
     */
    class MullImm : public IntegerImm
    {
      public:
        /// Constructor.
        MullImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mulq([' Rc    = Ra    * Rb_or_imm;    ', 'IntMultOp'],{})

    /**
     * Static instruction class for "mulq".
     */
    class Mulq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mulq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mulq".
     */
    class MulqImm : public IntegerImm
    {
      public:
        /// Constructor.
        MulqImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::umulh(['\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                Rc = hi;\n            ', 'IntMultOp'],{})

    /**
     * Static instruction class for "umulh".
     */
    class Umulh : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Umulh(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "umulh".
     */
    class UmulhImm : public IntegerImm
    {
      public:
        /// Constructor.
        UmulhImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mullv(['\n                // 32-bit multiply with trap on overflow\n                int64_t Rax = Ra_sl;    // sign extended version of Ra_sl\n                int64_t Rbx = Rb_or_imm_sl;\n                int64_t tmp = Rax * Rbx;\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = tmp<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Rc_sl = tmp<31:0>;\n            ', 'IntMultOp'],{})

    /**
     * Static instruction class for "mullv".
     */
    class Mullv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mullv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mullv".
     */
    class MullvImm : public IntegerImm
    {
      public:
        /// Constructor.
        MullvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::mulqv(['\n                // 64-bit multiply with trap on overflow\n                uint64_t hi, lo;\n                mul128(Ra, Rb_or_imm, hi, lo);\n                // all the upper 64 bits must match the sign bit of\n                // the lower 64\n                if (!((hi == 0 && lo<63:> == 0) ||\n                      (hi == mask(64) && lo<63:> == 1)))\n                    fault = new IntegerOverflowFault;\n                Rc = lo;\n            ', 'IntMultOp'],{})

    /**
     * Static instruction class for "mulqv".
     */
    class Mulqv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mulqv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "mulqv".
     */
    class MulqvImm : public IntegerImm
    {
      public:
        /// Constructor.
        MulqvImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::sextb([' Rc_sb = Rb_or_imm< 7:0>; '],{})

    /**
     * Static instruction class for "sextb".
     */
    class Sextb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Sextb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "sextb".
     */
    class SextbImm : public IntegerImm
    {
      public:
        /// Constructor.
        SextbImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::sextw([' Rc_sw = Rb_or_imm<15:0>; '],{})

    /**
     * Static instruction class for "sextw".
     */
    class Sextw : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Sextw(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "sextw".
     */
    class SextwImm : public IntegerImm
    {
      public:
        /// Constructor.
        SextwImm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// IntegerOperate::ctpop(['\n                             uint64_t count = 0;\n                             for (int i = 0; Rb<63:i>; ++i) {\n                                 if (Rb<i:i> == 0x1)\n                                     ++count;\n                             }\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "ctpop".
     */
    class Ctpop : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Ctpop(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::perr(['\n                             uint64_t temp = 0;\n                             int hi = 7;\n                             int lo = 0;\n                             for (int i = 0; i < 8; ++i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp += (ra_ub >= rb_ub) ? \n                                         (ra_ub - rb_ub) : (rb_ub - ra_ub);\n                                 hi += 8;\n                                 lo += 8;\n                             }\n                             Rc = temp;\n                           '],{})

    /**
     * Static instruction class for "perr".
     */
    class Perr : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Perr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::ctlz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (temp<63:32>) temp >>= 32; else count += 32;\n                             if (temp<31:16>) temp >>= 16; else count += 16;\n                             if (temp<15:8>) temp >>= 8; else count += 8;\n                             if (temp<7:4>) temp >>= 4; else count += 4;\n                             if (temp<3:2>) temp >>= 2; else count += 2;\n                             if (temp<1:1>) temp >>= 1; else count += 1;\n                             if ((temp<0:0>) != 0x1) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "ctlz".
     */
    class Ctlz : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Ctlz(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::cttz(['\n                             uint64_t count = 0;\n                             uint64_t temp = Rb;\n                             if (!(temp<31:0>)) { temp >>= 32; count += 32; }\n                             if (!(temp<15:0>)) { temp >>= 16; count += 16; }\n                             if (!(temp<7:0>)) { temp >>= 8; count += 8; }\n                             if (!(temp<3:0>)) { temp >>= 4; count += 4; }\n                             if (!(temp<1:0>)) { temp >>= 2; count += 2; }\n                             if (!(temp<0:0> & ULL(0x1))) { \n                                 temp >>= 1; count += 1; \n                             }\n                             if (!(temp<0:0> & ULL(0x1))) count += 1;\n                             Rc = count;\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "cttz".
     */
    class Cttz : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cttz(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::unpkbw([' \n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<15:8> << 16)\n                                   | (Rb_uq<23:16> << 32)\n                                   | (Rb_uq<31:24> << 48));\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "unpkbw".
     */
    class Unpkbw : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Unpkbw(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::unpkbl(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<15:8> << 32));\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "unpkbl".
     */
    class Unpkbl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Unpkbl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::pkwb(['\n                             Rc = (Rb_uq<7:0>\n                                   | (Rb_uq<23:16> << 8)\n                                   | (Rb_uq<39:32> << 16)\n                                   | (Rb_uq<55:48> << 24));\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "pkwb".
     */
    class Pkwb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Pkwb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::pklb(['\n                             Rc = (Rb_uq<7:0> | (Rb_uq<39:32> << 8));\n                           ', 'IntAluOp'],{})

    /**
     * Static instruction class for "pklb".
     */
    class Pklb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Pklb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::minsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb < rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "minsb8".
     */
    class Minsb8 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Minsb8(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::minsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "minsw4".
     */
    class Minsw4 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Minsw4(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::minub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub < rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "minub8".
     */
    class Minub8 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Minub8(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::minuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_sw = Ra_uq<hi:lo>;\n                                 uint16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw < rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "minuw4".
     */
    class Minuw4 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Minuw4(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::maxub8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 uint8_t ra_ub = Ra_uq<hi:lo>;\n                                 uint8_t rb_ub = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_ub > rb_ub) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "maxub8".
     */
    class Maxub8 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Maxub8(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::maxuw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 uint16_t ra_uw = Ra_uq<hi:lo>;\n                                 uint16_t rb_uw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_uw > rb_uw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "maxuw4".
     */
    class Maxuw4 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Maxuw4(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::maxsb8(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 56;\n                             for (int i = 7; i >= 0; --i) {\n                                 int8_t ra_sb = Ra_uq<hi:lo>;\n                                 int8_t rb_sb = Rb_uq<hi:lo>;\n                                 temp = ((temp << 8) \n                                         | ((ra_sb > rb_sb) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 8;\n                                 lo -= 8;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "maxsb8".
     */
    class Maxsb8 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Maxsb8(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// IntegerOperate::maxsw4(['\n                             uint64_t temp = 0;\n                             int hi = 63;\n                             int lo = 48;\n                             for (int i = 3; i >= 0; --i) {\n                                 int16_t ra_sw = Ra_uq<hi:lo>;\n                                 int16_t rb_sw = Rb_uq<hi:lo>;\n                                 temp = ((temp << 16) \n                                         | ((ra_sw > rb_sw) ? Ra_uq<hi:lo>\n                                                          : Rb_uq<hi:lo>));\n                                 hi -= 16;\n                                 lo -= 16;\n                             }\n                             Rc = temp;\n                          '],{})

    /**
     * Static instruction class for "maxsw4".
     */
    class Maxsw4 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Maxsw4(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::ftoit([' Rc = Fa_uq; ', 'FloatCvtOp'],{})

    /**
     * Static instruction class for "ftoit".
     */
    class Ftoit : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Ftoit(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::ftois([' Rc_sl = t_to_s(Fa_uq); ', 'FloatCvtOp'],{})

    /**
     * Static instruction class for "ftois".
     */
    class Ftois : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Ftois(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CondBranch::beq([' cond = (Ra == 0); '],{})

    /**
     * Static instruction class for "beq".
     */
    class Beq : public Branch
    {
      public:
        /// Constructor.
        Beq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::bne([' cond = (Ra != 0); '],{})

    /**
     * Static instruction class for "bne".
     */
    class Bne : public Branch
    {
      public:
        /// Constructor.
        Bne(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::bge([' cond = (Ra_sq >= 0); '],{})

    /**
     * Static instruction class for "bge".
     */
    class Bge : public Branch
    {
      public:
        /// Constructor.
        Bge(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::bgt([' cond = (Ra_sq >  0); '],{})

    /**
     * Static instruction class for "bgt".
     */
    class Bgt : public Branch
    {
      public:
        /// Constructor.
        Bgt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::ble([' cond = (Ra_sq <= 0); '],{})

    /**
     * Static instruction class for "ble".
     */
    class Ble : public Branch
    {
      public:
        /// Constructor.
        Ble(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::blt([' cond = (Ra_sq < 0); '],{})

    /**
     * Static instruction class for "blt".
     */
    class Blt : public Branch
    {
      public:
        /// Constructor.
        Blt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::blbc([' cond = ((Ra & 1) == 0); '],{})

    /**
     * Static instruction class for "blbc".
     */
    class Blbc : public Branch
    {
      public:
        /// Constructor.
        Blbc(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::blbs([' cond = ((Ra & 1) == 1); '],{})

    /**
     * Static instruction class for "blbs".
     */
    class Blbs : public Branch
    {
      public:
        /// Constructor.
        Blbs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fbeq([' cond = (Fa == 0); '],{})

    /**
     * Static instruction class for "fbeq".
     */
    class Fbeq : public Branch
    {
      public:
        /// Constructor.
        Fbeq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fbne([' cond = (Fa != 0); '],{})

    /**
     * Static instruction class for "fbne".
     */
    class Fbne : public Branch
    {
      public:
        /// Constructor.
        Fbne(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fbge([' cond = (Fa >= 0); '],{})

    /**
     * Static instruction class for "fbge".
     */
    class Fbge : public Branch
    {
      public:
        /// Constructor.
        Fbge(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fbgt([' cond = (Fa >  0); '],{})

    /**
     * Static instruction class for "fbgt".
     */
    class Fbgt : public Branch
    {
      public:
        /// Constructor.
        Fbgt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fble([' cond = (Fa <= 0); '],{})

    /**
     * Static instruction class for "fble".
     */
    class Fble : public Branch
    {
      public:
        /// Constructor.
        Fble(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// CondBranch::fblt([' cond = (Fa < 0); '],{})

    /**
     * Static instruction class for "fblt".
     */
    class Fblt : public Branch
    {
      public:
        /// Constructor.
        Fblt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// UncondBranch::br([],{})

    /**
     * Static instruction class for "br".
     */
    class Br : public Branch
    {
      public:
        /// Constructor.
        Br(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "br".
     */
    class BrAndLink : public Branch
    {
      public:
        /// Constructor.
        BrAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// UncondBranch::bsr(['IsCall'],{})

    /**
     * Static instruction class for "bsr".
     */
    class Bsr : public Branch
    {
      public:
        /// Constructor.
        Bsr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "bsr".
     */
    class BsrAndLink : public Branch
    {
      public:
        /// Constructor.
        BsrAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Jump::jmp([],{})

    /**
     * Static instruction class for "jmp".
     */
    class Jmp : public Jump
    {
      public:
        /// Constructor.
        Jmp(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "jmp".
     */
    class JmpAndLink : public Jump
    {
      public:
        /// Constructor.
        JmpAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Jump::jsr(['IsCall'],{})

    /**
     * Static instruction class for "jsr".
     */
    class Jsr : public Jump
    {
      public:
        /// Constructor.
        Jsr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "jsr".
     */
    class JsrAndLink : public Jump
    {
      public:
        /// Constructor.
        JsrAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Jump::ret(['IsReturn'],{})

    /**
     * Static instruction class for "ret".
     */
    class Ret : public Jump
    {
      public:
        /// Constructor.
        Ret(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ret".
     */
    class RetAndLink : public Jump
    {
      public:
        /// Constructor.
        RetAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Jump::jsr_coroutine(['IsCall', 'IsReturn'],{})

    /**
     * Static instruction class for "jsr_coroutine".
     */
    class Jsr_coroutine : public Jump
    {
      public:
        /// Constructor.
        Jsr_coroutine(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "jsr_coroutine".
     */
    class Jsr_coroutineAndLink : public Jump
    {
      public:
        /// Constructor.
        Jsr_coroutineAndLink(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::itofs([' Fc_uq = s_to_t(Ra_ul); ', 'FloatCvtOp'],{})

    /**
     * Static instruction class for "itofs".
     */
    class Itofs : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Itofs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::itoft([' Fc_uq = Ra_uq; ', 'FloatCvtOp'],{})

    /**
     * Static instruction class for "itoft".
     */
    class Itoft : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Itoft(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FailUnimpl::itoff(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::sqrts(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    /**
     * Static instruction class for "sqrts".
     */
    class Sqrts : public AlphaFP
    {
      public:
        /// Constructor.
        Sqrts(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };
#else

// FloatingPointOperate::sqrts(['\n                        if (Fb_sf < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc_sf = sqrt(Fb_sf);\n                    ', 'FloatSqrtOp'],{})

    /**
     * Static instruction class for "sqrts".
     */
    class Sqrts : public AlphaFP
    {
      public:
        /// Constructor.
        Sqrts(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };
#endif

// FloatingPointOperate::sqrtt(['\n                        if (Fb < 0.0)\n                            fault = new ArithmeticFault;\n                        Fc = sqrt(Fb);\n                    ', 'FloatSqrtOp'],{})

    /**
     * Static instruction class for "sqrtt".
     */
    class Sqrtt : public AlphaFP
    {
      public:
        /// Constructor.
        Sqrtt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FailUnimpl::sqrtfg(([], {}))

// Unknown::unknown(([], {}))
#if SS_COMPATIBLE_FP

// FloatingPointOperate::adds([' Fc = Fa + Fb; '],{})

    /**
     * Static instruction class for "adds".
     */
    class Adds : public AlphaFP
    {
      public:
        /// Constructor.
        Adds(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::subs([' Fc = Fa - Fb; '],{})

    /**
     * Static instruction class for "subs".
     */
    class Subs : public AlphaFP
    {
      public:
        /// Constructor.
        Subs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::muls([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    /**
     * Static instruction class for "muls".
     */
    class Muls : public AlphaFP
    {
      public:
        /// Constructor.
        Muls(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::divs([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    /**
     * Static instruction class for "divs".
     */
    class Divs : public AlphaFP
    {
      public:
        /// Constructor.
        Divs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };
#else

// FloatingPointOperate::adds([' Fc_sf = Fa_sf + Fb_sf; '],{})

    /**
     * Static instruction class for "adds".
     */
    class Adds : public AlphaFP
    {
      public:
        /// Constructor.
        Adds(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::subs([' Fc_sf = Fa_sf - Fb_sf; '],{})

    /**
     * Static instruction class for "subs".
     */
    class Subs : public AlphaFP
    {
      public:
        /// Constructor.
        Subs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::muls([' Fc_sf = Fa_sf * Fb_sf; ', 'FloatMultOp'],{})

    /**
     * Static instruction class for "muls".
     */
    class Muls : public AlphaFP
    {
      public:
        /// Constructor.
        Muls(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::divs([' Fc_sf = Fa_sf / Fb_sf; ', 'FloatDivOp'],{})

    /**
     * Static instruction class for "divs".
     */
    class Divs : public AlphaFP
    {
      public:
        /// Constructor.
        Divs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };
#endif

// FloatingPointOperate::addt([' Fc = Fa + Fb; '],{})

    /**
     * Static instruction class for "addt".
     */
    class Addt : public AlphaFP
    {
      public:
        /// Constructor.
        Addt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::subt([' Fc = Fa - Fb; '],{})

    /**
     * Static instruction class for "subt".
     */
    class Subt : public AlphaFP
    {
      public:
        /// Constructor.
        Subt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::mult([' Fc = Fa * Fb; ', 'FloatMultOp'],{})

    /**
     * Static instruction class for "mult".
     */
    class Mult : public AlphaFP
    {
      public:
        /// Constructor.
        Mult(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::divt([' Fc = Fa / Fb; ', 'FloatDivOp'],{})

    /**
     * Static instruction class for "divt".
     */
    class Divt : public AlphaFP
    {
      public:
        /// Constructor.
        Divt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cmpteq([' Fc = (Fa == Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    /**
     * Static instruction class for "cmpteq".
     */
    class Cmpteq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmpteq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cmptle([' Fc = (Fa <= Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    /**
     * Static instruction class for "cmptle".
     */
    class Cmptle : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmptle(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cmptlt([' Fc = (Fa <  Fb) ? 2.0 : 0.0; ', 'FloatCmpOp'],{})

    /**
     * Static instruction class for "cmptlt".
     */
    class Cmptlt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmptlt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cmptun([' // unordered\n                    Fc = (!(Fa < Fb) && !(Fa == Fb) && !(Fa > Fb)) ? 2.0 : 0.0;\n                ', 'FloatCmpOp'],{})

    /**
     * Static instruction class for "cmptun".
     */
    class Cmptun : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cmptun(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)trunc(Fb); ', 'Chopped'],{})

    /**
     * Static instruction class for "cvttq".
     */
    class CvttqChopped : public AlphaFP
    {
      public:
        /// Constructor.
        CvttqChopped(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FPFixedRounding::cvttq([' Fc_sq = (int64_t)floor(Fb); ', 'MinusInfinity'],{})

    /**
     * Static instruction class for "cvttq".
     */
    class CvttqMinusInfinity : public AlphaFP
    {
      public:
        /// Constructor.
        CvttqMinusInfinity(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::cvttq([' Fc_sq = (int64_t)nearbyint(Fb); '],{})

    /**
     * Static instruction class for "cvttq".
     */
    class Cvttq : public AlphaFP
    {
      public:
        /// Constructor.
        Cvttq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cvtst([' Fc = Fb_sf; '],{})

    /**
     * Static instruction class for "cvtst".
     */
    class Cvtst : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cvtst(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::cvtts([' Fc_sf = Fb; '],{})

    /**
     * Static instruction class for "cvtts".
     */
    class Cvtts : public AlphaFP
    {
      public:
        /// Constructor.
        Cvtts(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FloatingPointOperate::cvtqs([' Fc_sf = Fb_sq; '],{})

    /**
     * Static instruction class for "cvtqs".
     */
    class Cvtqs : public AlphaFP
    {
      public:
        /// Constructor.
        Cvtqs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// FloatingPointOperate::cvtqt([' Fc    = Fb_sq; '],{})

    /**
     * Static instruction class for "cvtqt".
     */
    class Cvtqt : public AlphaFP
    {
      public:
        /// Constructor.
        Cvtqt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BasicOperateWithNopCheck::cvtlq(['\n                Fc_sl = (Fb_uq<63:62> << 30) | Fb_uq<58:29>;\n            '],{})

    /**
     * Static instruction class for "cvtlq".
     */
    class Cvtlq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cvtlq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cvtql(['\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    /**
     * Static instruction class for "cvtql".
     */
    class Cvtql : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cvtql(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cvtqlv(['\n                // To avoid overflow, all the upper 32 bits must match\n                // the sign bit of the lower 32.  We code this as\n                // checking the upper 33 bits for all 0s or all 1s.\n                uint64_t sign_bits = Fb_uq<63:31>;\n                if (sign_bits != 0 && sign_bits != mask(33))\n                    fault = new IntegerOverflowFault;\n                Fc_uq = (Fb_uq<31:30> << 62) | (Fb_uq<29:0> << 29);\n            '],{})

    /**
     * Static instruction class for "cvtqlv".
     */
    class Cvtqlv : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cvtqlv(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cpys(['  // copy sign\n                Fc_uq = (Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    /**
     * Static instruction class for "cpys".
     */
    class Cpys : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cpys(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cpysn([' // copy sign negated\n                Fc_uq = (~Fa_uq<63:> << 63) | Fb_uq<62:0>;\n            '],{})

    /**
     * Static instruction class for "cpysn".
     */
    class Cpysn : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cpysn(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::cpyse([' // copy sign and exponent\n                Fc_uq = (Fa_uq<63:52> << 52) | Fb_uq<51:0>;\n            '],{})

    /**
     * Static instruction class for "cpyse".
     */
    class Cpyse : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Cpyse(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmoveq([' Fc = (Fa == 0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmoveq".
     */
    class Fcmoveq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmoveq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmovne([' Fc = (Fa != 0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmovne".
     */
    class Fcmovne : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmovne(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmovlt([' Fc = (Fa <  0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmovlt".
     */
    class Fcmovlt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmovlt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmovge([' Fc = (Fa >= 0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmovge".
     */
    class Fcmovge : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmovge(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmovle([' Fc = (Fa <= 0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmovle".
     */
    class Fcmovle : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmovle(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::fcmovgt([' Fc = (Fa >  0) ? Fb : Fc; '],{})

    /**
     * Static instruction class for "fcmovgt".
     */
    class Fcmovgt : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Fcmovgt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::mt_fpcr([' FPCR = Fa_uq; ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "mt_fpcr".
     */
    class Mt_fpcr : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mt_fpcr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperateWithNopCheck::mf_fpcr([' Fa_uq = FPCR; ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "mf_fpcr".
     */
    class Mf_fpcr : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mf_fpcr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// WarnUnimpl::fetch([],{})

// WarnUnimpl::fetch_m([],{})

// WarnUnimpl::ecb([],{})

// MiscPrefetch::wh64([' EA = Rb & ~ULL(63); ', ' ; '],{'mem_flags': 'PREFETCH'})

    /**
     * Static instruction class for "wh64".
     */
    class Wh64 : public MemoryNoDisp
    {
      public:

        /// Constructor.
        Wh64(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// BasicOperate::rpcc(['\n                /* Rb is a fake dependency so here is a fun way to get\n                 * the parser to understand that.\n                 */\n                uint64_t unused_var M5_VAR_USED = Rb;\n                Ra = FullSystem ? xc->readMiscReg(IPR_CC) : curTick();\n            ', 'IsUnverifiable'],{})

    /**
     * Static instruction class for "rpcc".
     */
    class Rpcc : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Rpcc(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::trapb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    /**
     * Static instruction class for "trapb".
     */
    class Trapb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Trapb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::excb([' ', 'IsSerializing', 'IsSerializeBefore', 'No_OpClass'],{})

    /**
     * Static instruction class for "excb".
     */
    class Excb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Excb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::mb([' ', 'IsMemBarrier', 'MemReadOp'],{})

    /**
     * Static instruction class for "mb".
     */
    class Mb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Mb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::wmb([' ', 'IsWriteBarrier', 'MemWriteOp'],{})

    /**
     * Static instruction class for "wmb".
     */
    class Wmb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Wmb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FailUnimpl::rc_se(([], {}))

// BasicOperate::rc((['\n                Ra = IntrFlag;\n                IntrFlag = 0;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    /**
     * Static instruction class for "rc".
     */
    class Rc : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Rc(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// FailUnimpl::rs_se(([], {}))

// BasicOperate::rs((['\n                Ra = IntrFlag;\n                IntrFlag = 1;\n            ', 'IsNonSpeculative', 'IsUnverifiable'], {}))

    /**
     * Static instruction class for "rs".
     */
    class Rs : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Rs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// EmulatedCallPal::halt(['\n                    exitSimLoop("halt instruction encountered");\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "halt".
     */
    class Halt : public EmulatedCallPal
    {
      public:
        /// Constructor.
        Halt(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// EmulatedCallPal::callsys(['\n                    xc->syscall(R0);\n                ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall'],{})

    /**
     * Static instruction class for "callsys".
     */
    class Callsys : public EmulatedCallPal
    {
      public:
        /// Constructor.
        Callsys(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// EmulatedCallPal::rduniq([' R0 = Runiq; ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "rduniq".
     */
    class Rduniq : public EmulatedCallPal
    {
      public:
        /// Constructor.
        Rduniq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// EmulatedCallPal::wruniq([' Runiq = R16; ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "wruniq".
     */
    class Wruniq : public EmulatedCallPal
    {
      public:
        /// Constructor.
        Wruniq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// CallPal::call_pal((['\n            if (!palValid ||\n                (palPriv\n                 && xc->readMiscReg(IPR_ICM) != mode_kernel)) {\n                // invalid pal function code, or attempt to do privileged\n                // PAL call in non-kernel mode\n                fault = new UnimplementedOpcodeFault;\n            } else {\n                // check to see if simulator wants to do something special\n                // on this PAL call (including maybe suppress it)\n                bool dopal = xc->simPalCheck(palFunc);\n\n                if (dopal) {\n                    xc->setMiscReg(IPR_EXC_ADDR, NPC);\n                    NPC = xc->readMiscReg(IPR_PAL_BASE) + palOffset;\n                }\n            }\n        ', 'IsNonSpeculative'], {}))

    /**
     * Static instruction class for "call_pal".
     */
    class Call_pal : public CallPalBase
    {
      public:
        /// Constructor.
        Call_pal(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// OpcdecFault::hw_st_quad(([], {}))

// HwLoad::hw_ld([' EA = (Rb + disp) & ~3; ', ' Ra = Mem_ul; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    /**
     * Static instruction class for "hw_ld".
     */
    class Hw_ldL : public HwLoadStore
    {
      public:

        /// Constructor.
        Hw_ldL(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// HwLoad::hw_ld([' EA = (Rb + disp) & ~7; ', ' Ra = Mem_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    /**
     * Static instruction class for "hw_ld".
     */
    class Hw_ldQ : public HwLoadStore
    {
      public:

        /// Constructor.
        Hw_ldQ(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_st_cond(([], {}))

// HwStore::hw_st([' EA = (Rb + disp) & ~3; ', ' Mem_ul = Ra<31:0>; ', 'L', 'IsSerializing', 'IsSerializeBefore'],{})

    /**
     * Static instruction class for "hw_st".
     */
    class Hw_stL : public HwLoadStore
    {
      public:

        /// Constructor.
        Hw_stL(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// HwStore::hw_st([' EA = (Rb + disp) & ~7; ', ' Mem_uq = Ra_uq; ', 'Q', 'IsSerializing', 'IsSerializeBefore'],{})

    /**
     * Static instruction class for "hw_st".
     */
    class Hw_stQ : public HwLoadStore
    {
      public:

        /// Constructor.
        Hw_stQ(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault eaComp(O3DynInst *, Trace::InstRecord *) const;

    Fault eaComp(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault eaComp(CheckerCPU *, Trace::InstRecord *) const;

    Fault eaComp(InOrderDynInst *, Trace::InstRecord *) const;

    Fault eaComp(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(InOrderDynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr, O3DynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, AtomicSimpleCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, CheckerCPU *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, InOrderDynInst *,
                      Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr, TimingSimpleCPU *,
                      Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// FailUnimpl::hw_st_cond(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mfpr(([], {}))

// HwMoveIPR::hw_mfpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsReadable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    Ra = xc->readMiscReg(miscRegIndex);\n            ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "hw_mfpr".
     */
    class Hw_mfpr : public HwMoveIPR
    {
      public:
        /// Constructor.
        Hw_mfpr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// OpcdecFault::hw_mtpr(([], {}))

// HwMoveIPR::hw_mtpr(['\n                int miscRegIndex = (ipr_index < MaxInternalProcRegs) ?\n                        IprToMiscRegIndex[ipr_index] : -1;\n                if(miscRegIndex < 0 || !IprIsWritable(miscRegIndex) ||\n                    miscRegIndex >= NumInternalProcRegs)\n                        fault = new UnimplementedOpcodeFault;\n                else\n                    xc->setMiscReg(miscRegIndex, Ra);\n                if (traceData) { traceData->setData(Ra); }\n            ', 'IsIprAccess'],{})

    /**
     * Static instruction class for "hw_mtpr".
     */
    class Hw_mtpr : public HwMoveIPR
    {
      public:
        /// Constructor.
        Hw_mtpr(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// OpcdecFault::hw_rei(([], {}))

// BasicOperate::hw_rei([' xc->hwrei(); ', 'IsSerializing', 'IsSerializeBefore'],{})

    /**
     * Static instruction class for "hw_rei".
     */
    class Hw_rei : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Hw_rei(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// BasicOperate::arm(['\n                PseudoInst::arm(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "arm".
     */
    class Arm : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Arm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::quiesce(["\n                // Don't sleep if (unmasked) interrupts are pending\n                Interrupts* interrupts =\n                    xc->tcBase()->getCpuPtr()->getInterruptController();\n                if (interrupts->checkInterrupts(xc->tcBase())) {\n                    PseudoInst::quiesceSkip(xc->tcBase());\n                } else {\n                    PseudoInst::quiesce(xc->tcBase());\n                }\n            ", 'IsNonSpeculative', 'IsQuiesce'],{})

    /**
     * Static instruction class for "quiesce".
     */
    class Quiesce : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Quiesce(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::quiesceNs(['\n                PseudoInst::quiesceNs(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce'],{})

    /**
     * Static instruction class for "quiesceNs".
     */
    class QuiesceNs : public AlphaStaticInst
    {
      public:
        /// Constructor.
        QuiesceNs(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::quiesceCycles(['\n                PseudoInst::quiesceCycles(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsQuiesce', 'IsUnverifiable'],{})

    /**
     * Static instruction class for "quiesceCycles".
     */
    class QuiesceCycles : public AlphaStaticInst
    {
      public:
        /// Constructor.
        QuiesceCycles(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::quiesceTime(['\n                R0 = PseudoInst::quiesceTime(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    /**
     * Static instruction class for "quiesceTime".
     */
    class QuiesceTime : public AlphaStaticInst
    {
      public:
        /// Constructor.
        QuiesceTime(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::rpns(['\n                R0 = PseudoInst::rpns(xc->tcBase());\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    /**
     * Static instruction class for "rpns".
     */
    class Rpns : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Rpns(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::wakeCPU(['\n                PseudoInst::wakeCPU(xc->tcBase(), R16);\n            ', 'IsNonSpeculative', 'IsUnverifiable'],{})

    /**
     * Static instruction class for "wakeCPU".
     */
    class WakeCPU : public AlphaStaticInst
    {
      public:
        /// Constructor.
        WakeCPU(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::deprecated_ivlb(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    /**
     * Static instruction class for "deprecated_ivlb".
     */
    class Deprecated_ivlb : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Deprecated_ivlb(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::deprecated_ivle(['\n                warn_once("Obsolete M5 ivlb instruction encountered.\\n");\n            '],{})

    /**
     * Static instruction class for "deprecated_ivle".
     */
    class Deprecated_ivle : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Deprecated_ivle(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::deprecated_exit(['\n                warn_once("deprecated M5 exit instruction encountered.\\n");\n                PseudoInst::m5exit(xc->tcBase(), 0);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "deprecated_exit".
     */
    class Deprecated_exit : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Deprecated_exit(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5exit(['\n                PseudoInst::m5exit(xc->tcBase(), R16);\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5exit".
     */
    class M5exit : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5exit(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::loadsymbol(['\n                PseudoInst::loadsymbol(xc->tcBase());\n            ', 'No_OpClass', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "loadsymbol".
     */
    class Loadsymbol : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Loadsymbol(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::initparam(['\n                Ra = PseudoInst::initParam(xc->tcBase());\n            '],{})

    /**
     * Static instruction class for "initparam".
     */
    class Initparam : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Initparam(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::resetstats(['\n                PseudoInst::resetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "resetstats".
     */
    class Resetstats : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Resetstats(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::dumpstats(['\n                PseudoInst::dumpstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "dumpstats".
     */
    class Dumpstats : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Dumpstats(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::dumpresetstats(['\n                PseudoInst::dumpresetstats(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "dumpresetstats".
     */
    class Dumpresetstats : public AlphaStaticInst
    {
      public:
        /// Constructor.
        Dumpresetstats(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5checkpoint(['\n                PseudoInst::m5checkpoint(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5checkpoint".
     */
    class M5checkpoint : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5checkpoint(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5readfile(['\n                R0 = PseudoInst::readfile(xc->tcBase(), R16, R17, R18);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5readfile".
     */
    class M5readfile : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5readfile(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5break(['\n                PseudoInst::debugbreak(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5break".
     */
    class M5break : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5break(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5switchcpu(['\n                PseudoInst::switchcpu(xc->tcBase());\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5switchcpu".
     */
    class M5switchcpu : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5switchcpu(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5addsymbol(['\n                PseudoInst::addsymbol(xc->tcBase(), R16, R17);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5addsymbol".
     */
    class M5addsymbol : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5addsymbol(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5panic(['\n                panic("M5 panic instruction called at pc = %#x.", PC);\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5panic".
     */
    class M5panic : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5panic(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };
#define  CPANN(lbl) CPA::cpa()->lbl(xc->tcBase())

// BasicOperate::m5a_old(['\n                    panic("Deprecated M5 annotate instruction executed "\n                          "at pc = %#x\\n", PC);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_old".
     */
    class M5a_old : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_old(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_bsm(['\n                    CPANN(swSmBegin);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_bsm".
     */
    class M5a_bsm : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_bsm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_esm(['\n                    CPANN(swSmEnd);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_esm".
     */
    class M5a_esm : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_esm(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_begin(['\n                    CPANN(swExplictBegin);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_begin".
     */
    class M5a_begin : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_begin(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_end(['\n                    CPANN(swEnd);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_end".
     */
    class M5a_end : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_end(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_q(['\n                    CPANN(swQ);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_q".
     */
    class M5a_q : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_q(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_dq(['\n                    CPANN(swDq);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_dq".
     */
    class M5a_dq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_dq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_wf(['\n                    CPANN(swWf);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_wf".
     */
    class M5a_wf : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_wf(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_we(['\n                    CPANN(swWe);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_we".
     */
    class M5a_we : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_we(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_sq(['\n                    CPANN(swSq);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_sq".
     */
    class M5a_sq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_sq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_aq(['\n                    CPANN(swAq);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_aq".
     */
    class M5a_aq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_aq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_pq(['\n                    CPANN(swPq);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_pq".
     */
    class M5a_pq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_pq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_l(['\n                    CPANN(swLink);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_l".
     */
    class M5a_l : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_l(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_identify(['\n                    CPANN(swIdentify);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_identify".
     */
    class M5a_identify : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_identify(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_getid(['\n                    R0 = CPANN(swGetId);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_getid".
     */
    class M5a_getid : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_getid(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_scl(['\n                    CPANN(swSyscallLink);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_scl".
     */
    class M5a_scl : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_scl(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5a_rq(['\n                    CPANN(swRq);\n                ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5a_rq".
     */
    class M5a_rq : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5a_rq(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))
#undef CPANN

// BasicOperate::m5reserved2(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5reserved2".
     */
    class M5reserved2 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5reserved2(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5reserved3(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5reserved3".
     */
    class M5reserved3 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5reserved3(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5reserved4(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5reserved4".
     */
    class M5reserved4 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5reserved4(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// BasicOperate::m5reserved5(['\n                warn("M5 reserved opcode ignored");\n            ', 'IsNonSpeculative'],{})

    /**
     * Static instruction class for "m5reserved5".
     */
    class M5reserved5 : public AlphaStaticInst
    {
      public:
        /// Constructor.
        M5reserved5(ExtMachInst machInst);

        
    Fault execute(O3DynInst *, Trace::InstRecord *) const;

    Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault execute(CheckerCPU *, Trace::InstRecord *) const;

    Fault execute(InOrderDynInst *, Trace::InstRecord *) const;

    Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))


} // namespace AlphaISAInst


